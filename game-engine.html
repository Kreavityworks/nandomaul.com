<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber-Soldier: SATISFYING EDITION</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
            "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js"
        }
    }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700;900&family=Share+Tech+Mono&display=swap');
        
        body { 
            margin: 0; overflow: hidden; background-color: #050505; 
            font-family: 'Rajdhani', sans-serif;
            user-select: none; cursor: none; touch-action: none; 
        }
        
        .font-tech { font-family: 'Share Tech Mono', monospace; }
        .font-raj { font-family: 'Rajdhani', sans-serif; font-weight: 700; }

        #canvas-container { 
            width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1;
            /* TRANSFORM SCALE 1.15 -> Zoom in 15% to crop edges (Potong atas bawah) */
            transform: scale(1.15); 
            transform-origin: center;
        }
        
        .ui-layer { position: absolute; z-index: 10; pointer-events: none; }
        .interactive { pointer-events: auto; cursor: default; }

        #custom-cursor {
            position: absolute; width: 40px; height: 40px; border: 2px solid #ffffff; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 9999;
            box-shadow: 0 0 15px #ffffff; transition: transform 0.05s; mix-blend-mode: difference;
        }
        #cursor-dot {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: red; 
            border-radius: 50%; transform: translate(-50%, -50%);
        }
        
        /* MOBILE CONTROLS */
        #mobile-controls { display: none; }
        @media (max-width: 1024px) {
            #mobile-controls { display: block; position: absolute; bottom: 20px; width: 100%; height: 200px; z-index: 20; pointer-events: none; }
            .joystick-zone { position: absolute; bottom: 20px; width: 140px; height: 140px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(0, 255, 255, 0.3); border-radius: 50%; pointer-events: auto; backdrop-filter: blur(2px); }
            #stick-left { left: 30px; }
            #stick-right { right: 30px; }
            .stick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(0, 255, 255, 0.5); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 15px cyan; pointer-events: none; }
            #mobile-btns { position: absolute; right: 190px; bottom: 40px; display: flex; gap: 15px; pointer-events: auto; }
            .mob-btn { width: 60px; height: 60px; border-radius: 50%; border: 2px solid white; background: rgba(0,0,0,0.5); color: white; font-size: 10px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-family: 'Share Tech Mono'; }
            .mob-btn:active { background: white; color: black; }
            #custom-cursor { display: none; }
            #hud { transform: scale(0.8); transform-origin: bottom left; width: 120%; }
        }

        #reload-bar-bg {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            width: 40px; height: 6px; background: rgba(0,0,0,0.8);
            border: 1px solid #0088ff; border-radius: 4px;
            display: none; overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 136, 255, 0.3);
        }
        #reload-bar-fill { width: 0%; height: 100%; background: #0088ff; box-shadow: 0 0 10px #0088ff; }

        /* --- ADVANCED GLITCH EFFECT --- */
        .glitch-wrapper {
            position: relative;
            color: white;
        }
        .glitch-wrapper::before,
        .glitch-wrapper::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent; 
        }
        .glitch-wrapper::before {
            left: 2px;
            text-shadow: -2px 0 #ff00c1;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim 5s infinite linear alternate-reverse;
        }
        .glitch-wrapper::after {
            left: -2px;
            text-shadow: -2px 0 #00fff9;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim 2s infinite linear alternate-reverse;
        }
        @keyframes glitch-anim {
            0% { clip: rect(59px, 9999px, 73px, 0); transform: skew(0.3deg); }
            5% { clip: rect(78px, 9999px, 92px, 0); transform: skew(0.3deg); }
            10% { clip: rect(9px, 9999px, 12px, 0); transform: skew(0.3deg); }
            15% { clip: rect(18px, 9999px, 83px, 0); transform: skew(0.3deg); }
            20% { clip: rect(61px, 9999px, 6px, 0); transform: skew(0.3deg); }
            25% { clip: rect(32px, 9999px, 99px, 0); transform: skew(0.3deg); }
            30% { clip: rect(93px, 9999px, 92px, 0); transform: skew(0.3deg); }
            35% { clip: rect(11px, 9999px, 46px, 0); transform: skew(0.3deg); }
            40% { clip: rect(2px, 9999px, 26px, 0); transform: skew(0.3deg); }
            45% { clip: rect(10px, 9999px, 1px, 0); transform: skew(0.3deg); }
            50% { clip: rect(65px, 9999px, 98px, 0); transform: skew(0.3deg); }
            55% { clip: rect(17px, 9999px, 35px, 0); transform: skew(0.3deg); }
            60% { clip: rect(87px, 9999px, 2px, 0); transform: skew(0.3deg); }
            65% { clip: rect(48px, 9999px, 76px, 0); transform: skew(0.3deg); }
            70% { clip: rect(23px, 9999px, 52px, 0); transform: skew(0.3deg); }
            75% { clip: rect(96px, 9999px, 19px, 0); transform: skew(0.3deg); }
            80% { clip: rect(34px, 9999px, 11px, 0); transform: skew(0.3deg); }
            85% { clip: rect(62px, 9999px, 78px, 0); transform: skew(0.3deg); }
            90% { clip: rect(16px, 9999px, 88px, 0); transform: skew(0.3deg); }
            95% { clip: rect(38px, 9999px, 12px, 0); transform: skew(0.3deg); }
            100% { clip: rect(82px, 9999px, 39px, 0); transform: skew(0.3deg); }
        }

        .fade-in-up { animation: fadeInUp 0.8s ease-out forwards; opacity: 0; transform: translateY(20px); }
        @keyframes fadeInUp { to { opacity: 1; transform: translateY(0); } }

        .btn-epic { 
            background: transparent; border: 2px solid cyan; color: cyan; box-shadow: 0 0 15px cyan; transition: all 0.3s;
            font-family: 'Rajdhani', sans-serif; letter-spacing: 4px;
        }
        .btn-epic:hover { background: cyan; color: black; box-shadow: 0 0 30px cyan; transform: scale(1.05); }

        #leech-warning {
            position: absolute; top: 65%; left: 50%; transform: translate(-50%, -50%);
            color: #ccff00; font-weight: 900; font-size: 28px; letter-spacing: 2px;
            display: none; text-shadow: 0 0 15px #ccff00;
            animation: tapPanic 0.15s infinite alternate; pointer-events: none;
            font-family: 'Share Tech Mono';
        }
        @keyframes tapPanic { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.2); } }
        
        #slowed-label {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            color: #ff4444; font-weight: 900; font-size: 16px; letter-spacing: 2px;
            display: none; text-shadow: 0 0 10px #ff0000; pointer-events: none;
            font-family: 'Share Tech Mono';
        }

        .key-bubble {
            width: 30px; height: 30px; border: 2px solid white; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 12px; box-shadow: 0 0 5px white;
            color: white; background: rgba(0,0,0,0.5); transition: all 0.1s ease-out;
            font-family: 'Share Tech Mono';
        }
        .tip-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 12px; color: #ccc; font-family: 'Rajdhani'; font-weight: 600; }
        .key-active { background-color: white !important; color: black !important; box-shadow: 0 0 15px white !important; transform: scale(1.15); border-color: white !important; }

        @keyframes ammoFlip {
            0% { transform: rotateX(0deg); color: white; opacity: 1; }
            50% { transform: rotateX(90deg); color: red; opacity: 0.5; }
            100% { transform: rotateX(0deg); color: white; opacity: 1; }
        }
        .reloading-text { animation: ammoFlip 0.8s infinite linear; }

        #notification-zone {
            position: absolute; top: 20px; right: 20px; width: 250px;
            display: flex; flex-direction: column; align-items: flex-end; gap: 5px;
            pointer-events: none;
        }
        .notif-card {
            background: rgba(0, 0, 0, 0.5);
            border-right: 3px solid cyan;
            padding: 8px 15px; color: rgba(255,255,255,0.9); font-weight: bold; font-family: 'Share Tech Mono'; font-size: 14px;
            text-shadow: 0 0 5px cyan; transform: translateX(100%);
            animation: slideInRight 0.3s forwards, slideOutRight 0.3s 1.7s forwards;
        }
        @keyframes slideInRight { to { transform: translateX(0); } }
        @keyframes slideOutRight { to { transform: translateX(120%); } }

        .credits {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            font-size: 12px; /* Increased Size */
            color: rgba(255,255,255,1.0); /* Full Opacity */
            letter-spacing: 3px;
            font-weight: 900; /* Extra Bold */
            text-shadow: 0 0 10px cyan; /* Glow Effect */
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase;
            animation: pulseText 3s infinite;
        }
        @keyframes pulseText { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; text-shadow: 0 0 20px cyan; } }

        /* PAUSE SCREEN */
        #pause-screen { height: 100vh; bottom: 0; top: auto; }

        /* SCREENS POS */
        #hud { height: 100vh; bottom: 0; top: auto; }
        #start-screen { height: 100vh; bottom: 0; top: auto; }
        #game-over { height: 100vh; bottom: 0; top: auto; }
        #frost-overlay { height: 100vh; bottom: 0; top: auto; }

        .controls-list {
            margin-top: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px 20px;
            text-align: left;
            font-size: 12px;
            color: #ddd;
            font-family: 'Share Tech Mono';
        }
        .controls-list .key { color: cyan; font-weight: bold; }
    </style>
</head>
<body>

    <audio id="bgm" src="public/11-musicgame/musicbackground.mp4" loop></audio>

    <div id="canvas-container"></div>
    <div id="frost-overlay" class="absolute hidden pointer-events-none z-20" style="width: 100vw; background: radial-gradient(circle, transparent 60%, rgba(0, 255, 255, 0.3) 100%);"></div>
    
    <div id="custom-cursor">
        <div id="cursor-dot"></div>
        <div id="reload-bar-bg"><div id="reload-bar-fill"></div></div>
    </div>
    
    <div id="mobile-controls">
        <div id="stick-left" class="joystick-zone"><div class="stick-knob" id="knob-left"></div></div>
        <div id="stick-right" class="joystick-zone"><div class="stick-knob" id="knob-right"></div></div>
        <div id="mobile-btns">
            <div class="mob-btn" id="btn-dash">DASH</div>
            <div class="mob-btn" id="btn-melee">HIT</div>
            <div class="mob-btn" id="btn-mol">MOL</div>
        </div>
    </div>

    <div id="leech-warning">PRESS [F] TO DETACH!</div>
    <div id="slowed-label">SLOWED</div>

    <!-- START SCREEN (Updated with Blue BG and Glitch) -->
    <div id="start-screen" class="ui-layer interactive w-full flex flex-col items-center justify-center z-50 backdrop-blur-md" style="background: rgba(0, 15, 40, 0.65);">
        <h1 class="text-6xl md:text-8xl font-black text-white mb-8 tracking-tighter fade-in-up glitch-wrapper text-center font-raj" data-text="NEON CHAOS">NEON CHAOS</h1>
        <div class="flex gap-8 items-center fade-in-up" style="animation-delay: 0.2s;">
            <button id="btn-start" class="px-20 py-6 text-2xl font-bold uppercase tracking-widest btn-epic">
                INITIATE
            </button>
        </div>
        <div class="controls-list fade-in-up" style="animation-delay: 0.3s;">
            <div><span class="key">[WASD]</span> MOVE</div>
            <div><span class="key">[MOUSE]</span> AIM</div>
            <div><span class="key">[CLICK]</span> SHOOT</div>
            <div><span class="key">[SPACE]</span> DASH</div>
            <div><span class="key">[F]</span> MELEE / DETACH</div>
            <div><span class="key">[E]</span> MOLOTOV</div>
            <div><span class="key">[R]</span> RELOAD</div>
            <div><span class="key">[1-3]</span> WEAPONS</div>
            <div><span class="key">[ESC]</span> PAUSE</div>
        </div>
        <div class="credits">DESIGN & DEVELOP GAME BY NANDO</div>
    </div>

    <!-- PAUSE SCREEN -->
    <div id="pause-screen" class="ui-layer interactive w-full hidden flex-col items-center justify-center bg-black/80 z-50 backdrop-blur-md">
        <h1 class="text-6xl font-black text-white mb-8 tracking-widest font-raj" style="text-shadow: 0 0 20px cyan;">SYSTEM PAUSED</h1>
        <div class="flex flex-col gap-4 items-center">
            <button id="btn-resume" class="px-16 py-4 bg-transparent border border-white text-white font-bold hover:bg-white hover:text-black transition uppercase tracking-widest w-64 font-raj">RESUME</button>
            <button id="btn-restart-pause" class="px-16 py-4 bg-transparent border border-red-500 text-red-500 font-bold hover:bg-red-500 hover:text-white transition uppercase tracking-widest w-64 font-raj">RESTART</button>
            <button id="btn-music" class="px-16 py-4 bg-transparent border border-cyan-500 text-cyan-500 font-bold hover:bg-cyan-500 hover:text-black transition uppercase tracking-widest w-64 font-raj">MUSIC: ON</button>
        </div>
        <div class="controls-list mt-8">
            <div><span class="key">[WASD]</span> MOVE</div>
            <div><span class="key">[SPACE]</span> DASH</div>
            <div><span class="key">[F]</span> MELEE</div>
            <div><span class="key">[E]</span> MOLOTOV</div>
        </div>
        <div class="credits">DESIGN & DEVELOP GAME BY NANDO</div>
    </div>

    <div id="notification-zone" class="ui-layer"></div>

    <div id="hud" class="ui-layer w-full hidden">
        <div class="absolute top-6 left-6 w-80 font-tech scale-75 origin-top-left md:scale-100">
            <div class="flex justify-between text-xs text-white mb-1 font-bold"><span>HP STATUS</span></div>
            <div class="w-full h-5 bg-black/60 border border-white transform -skew-x-12 overflow-hidden shadow-[0_0_10px_#ffffff]">
                <div id="bar-hp" class="h-full w-full transition-all duration-200" style="background: linear-gradient(90deg, #555, #fff);"></div>
            </div>
            <div class="flex justify-between text-xs text-gray-300 mt-2 mb-1 font-bold"><span>STAMINA</span></div>
            <div class="w-full h-2 bg-black/60 border border-gray-500 transform -skew-x-12">
                <div id="bar-sp" class="h-full bg-gray-400 w-full transition-all duration-200"></div>
            </div>
            <div class="flex justify-between text-xs text-orange-400 mt-4 mb-1 font-bold">
                <span>MOLOTOV [E]</span><span id="molotov-count" class="text-white">x2</span>
            </div>
            <div class="w-32 h-1 bg-black/60 border border-orange-600">
                <div id="bar-molotov" class="h-full bg-orange-500 w-full transition-all duration-100"></div>
            </div>
            <div id="q-indicator" class="mt-4 text-xs font-bold text-white border border-white p-2 inline-block">AUTO-FIRE [Q]: <span id="q-status">ON</span></div>
        </div>

        <div class="absolute top-6 left-1/2 -translate-x-1/2 text-center w-full pointer-events-none">
            <div id="timer" class="text-5xl font-black text-white tracking-widest drop-shadow-[0_0_10px_white] font-tech">00:00</div>
            <div id="level-display" class="text-sm font-bold text-cyan-400 tracking-widest mt-1 font-raj">THREAT LEVEL: 1</div>
        </div>

        <div class="absolute bottom-6 right-6 text-right font-tech scale-75 origin-bottom-right md:scale-100 pointer-events-none">
            <div id="weapon-name" class="text-6xl font-black text-white italic uppercase tracking-tighter font-raj" style="text-shadow: 0 0 15px white;">SMG</div>
            <div class="flex justify-end items-end gap-2 mt-2" id="ammo-container">
                <div class="text-6xl font-bold text-white leading-none" id="ammo-cur">50</div>
                <div class="text-2xl text-gray-500 mb-1">/ <span id="ammo-max">âˆž</span></div>
            </div>
        </div>

        <div class="absolute bottom-6 left-6 font-mono pointer-events-none transition-all hidden md:block">
            <div class="tip-row"><div id="key-w" class="key-bubble">W</div><div id="key-a" class="key-bubble">A</div><div id="key-s" class="key-bubble">S</div><div id="key-d" class="key-bubble">D</div> <span>MOVE</span></div>
            <div class="tip-row"><div id="key-spc" class="key-bubble">SPC</div> <span>DASH (10 SP)</span></div>
            <div class="tip-row"><div id="key-f" class="key-bubble">F</div> <span>MELEE (8 SP)</span></div>
            <div class="tip-row"><div id="key-e" class="key-bubble">E</div> <span>MOLOTOV</span></div>
            <div class="tip-row"><div id="key-q" class="key-bubble">Q</div> <span>AUTO-AIM</span></div>
            <div class="tip-row"><div id="key-1" class="key-bubble">1</div><div id="key-2" class="key-bubble">2</div><div id="key-3" class="key-bubble">3</div> <span>WEAPON</span></div>
        </div>

        <div class="credits">DESIGN & DEVELOP GAME BY NANDO</div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over" class="ui-layer interactive w-full hidden flex-col items-center justify-center bg-red-900/40 backdrop-blur-md z-50">
        <div class="glitch-text text-6xl md:text-7xl font-black text-white mb-4 tracking-tighter drop-shadow-lg text-center font-raj">SYSTEM FAILURE</div>
        <div class="text-3xl text-white font-tech mb-8 fade-in-up">SURVIVED: <span id="final-time" class="font-bold text-yellow-300">00:00</span></div>
        <button id="btn-restart" class="px-16 py-4 bg-white text-black font-bold hover:bg-gray-200 transition uppercase tracking-widest cursor-pointer shadow-2xl fade-in-up font-raj" style="animation-delay: 0.2s;">REBOOT SYSTEM</button>
        <div class="controls-list mt-8 fade-in-up" style="animation-delay: 0.4s;">
            <div><span class="key">[R]</span> RELOAD FASTER</div>
            <div><span class="key">[F]</span> DETACH LEECH</div>
        </div>
        <div class="credits">DESIGN & DEVELOP GAME BY NANDO</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

        // --- CONFIG ---
        const CONFIG = {
            ARENA_SIZE: 75,
            SPEED_BASE: 14,
            SPEED_DASH: 35,
            COLORS: {
                PLAYER: 0xffffff, SCOUT: 0x00ffaa, RUSHER: 0xffaa00, HEAVY: 0xff003c,
                SHOOTER: 0xaa00ff, TYRANT: 0x000000, ELITE: 0xff00ff, PYRO: 0xd90036,
                LEECH: 0xccff00, BG: 0x050505, GRID: 0x444444, NEON_CYAN: 0x00ffff
            }
        };

        const CAM_MODE = {
            DEFAULT: new THREE.Vector3(0, 34, 21), 
            SNIPER: new THREE.Vector3(0, 57, 38)
        };

        const STATE = {
            isRunning: false, paused: false, time: 0, lastMeteor: 0, hellRain: false,
            autoFireActive: true, level: 1, nextLevelTime: 30,
            mapGlitching: false, glitchTimer: 0,
            mobile: false, musicOn: true, lastFirework: 0
        };

        const PLAYER = {
            hp: 100, maxHp: 100, sp: 100, maxSp: 100, wepIdx: 0,
            reloading: false, dashCd: false, molotovCharges: 2,
            molotovMaxCharges: 2, molotovRecharge: 0, molotovRechargeTime: 3,
            frozenTimer: 0, leechAttached: false, leechSlowTimer: 0,
            isDashing: false, dashTimer: 0
        };

        const WEAPONS = [
            { name: 'SMG', dmg: 8, ammo: 50, max: 50, rate: 0.05, spread: 0.08, lastShot: 0 },
            { name: 'SHOTGUN', dmg: 18, ammo: 6, max: 6, rate: 0.8, spread: 0.5, pellets: 8, lastShot: 0 },
            { name: 'SNIPER', dmg: 120, ammo: 4, max: 4, rate: 1.6, spread: 0.001, pellets: 1, lastShot: 0 }
        ];

        let scene, camera, renderer, composer, glitchPass, world, physMat;
        let playerMesh, playerBody;
        let clock, delta;
        let spawnInterval;
        let spawnRate = 300; 
        let maxEnemies = 200; 
        
        let enemies = [], bullets = [], enemyBullets = [], enemyProjectiles = [], particles = [], loot = [], props = [], dynamicProps = [], fireZones = [];
        let attachedLeechMesh = null;
        
        // POOLING & OPTIMIZATION
        const geoms = {}; const mats = {}; const gradients = {};
        let hpBarTexture, buildingTexture;

        const keys = { w:0, a:0, s:0, d:0, click:0 };
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const groundPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
        let orbitAngle = 0;

        let audioCtx;
        function initAudio() { if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

        function toggleMusic() {
            initAudio(); 
            const bgm = document.getElementById('bgm');
            const btn = document.getElementById('btn-music');
            if (bgm.paused) {
                bgm.play().then(() => {
                    STATE.musicOn = true;
                    btn.innerText = "MUSIC: ON";
                    btn.style.color = "cyan"; 
                }).catch(e => console.log(e));
            } else {
                bgm.pause();
                STATE.musicOn = false;
                btn.innerText = "MUSIC: OFF";
                btn.style.color = "gray"; 
            }
        }

        function playSound(type) {
            if(!audioCtx || audioCtx.state === 'suspended') return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);

            // VOLUME BALANCING APPLIED
            if(type === 'melee') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(800, t + 0.1);
                const filter = audioCtx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.setValueAtTime(500, t); filter.frequency.linearRampToValueAtTime(3000, t + 0.1);
                osc.disconnect(); osc.connect(filter); filter.connect(gain);
                gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 0.15);
                osc.start(t); osc.stop(t + 0.15);
            } else if(type === 'reload') {
                osc.type = 'square'; osc.frequency.setValueAtTime(200, t); gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                osc.start(t); osc.stop(t + 0.05);
                const osc2 = audioCtx.createOscillator(); const gain2 = audioCtx.createGain();
                osc2.connect(gain2); gain2.connect(audioCtx.destination);
                osc2.type = 'square'; osc2.frequency.setValueAtTime(300, t+0.2); gain2.gain.setValueAtTime(0.1, t+0.2); gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.25);
                osc2.start(t+0.2); osc2.stop(t + 0.25);
            } else if(type === 'dash') {
                const bufferSize = audioCtx.sampleRate * 0.3; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0); for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(200, t); filter.frequency.linearRampToValueAtTime(800, t + 0.2);
                noise.connect(filter); filter.connect(gain);
                gain.gain.setValueAtTime(0.15, t); gain.gain.linearRampToValueAtTime(0, t + 0.3);
                noise.start(t);
            } else if (type === 'ui_start') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(440, t); osc.frequency.exponentialRampToValueAtTime(880, t+0.2);
                gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.2);
                osc.start(t); osc.stop(t+0.2);
            } else if (type === 'ui_pause') {
                osc.type = 'square'; osc.frequency.setValueAtTime(220, t); osc.frequency.linearRampToValueAtTime(110, t+0.2);
                gain.gain.setValueAtTime(0.15, t); gain.gain.linearRampToValueAtTime(0, t+0.2);
                osc.start(t); osc.stop(t+0.2);
            } else if (type === 'ui_over') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(20, t+1.0);
                gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.01, t+1.0);
                osc.start(t); osc.stop(t+1.0);
            }
        }

        function playHitSound(wepIdx) {
            if(!audioCtx || audioCtx.state === 'suspended') return;
            const t = audioCtx.currentTime;
            
            if (wepIdx === 0) { // SMG - Light "Tek"
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.type = 'triangle'; osc.frequency.setValueAtTime(1200, t); osc.frequency.exponentialRampToValueAtTime(500, t+0.05);
                gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.05);
                osc.start(t); osc.stop(t+0.05);
            } else if (wepIdx === 1) { // SHOTGUN - Heavy "Crazh"
                const bufferSize = audioCtx.sampleRate * 0.1; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0); for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
                const gain = audioCtx.createGain();
                noise.connect(gain); gain.connect(audioCtx.destination);
                gain.gain.setValueAtTime(0.25, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.1);
                noise.start(t);
            } else if (wepIdx === 2) { // SNIPER - Piercing "Pang"
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.type = 'sine'; osc.frequency.setValueAtTime(2000, t); osc.frequency.exponentialRampToValueAtTime(1000, t+0.2);
                gain.gain.setValueAtTime(0.2, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.2);
                osc.start(t); osc.stop(t+0.2);
            }
        }

        function playGunSound(type) {
            if(!audioCtx || audioCtx.state === 'suspended') return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);

            if(type === 'SMG') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, t); osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                gain.gain.setValueAtTime(0.08, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1); 
                osc.start(t); osc.stop(t + 0.1);
            } else if(type === 'SHOTGUN') {
                // CRISPIER SHOTGUN: Noise + Low Kick
                const bufferSize = audioCtx.sampleRate * 0.3; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0); for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
                
                const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(3000, t); filter.frequency.exponentialRampToValueAtTime(100, t+0.2);
                
                const noiseGain = audioCtx.createGain();
                noise.connect(filter); filter.connect(noiseGain); noiseGain.connect(audioCtx.destination);
                noiseGain.gain.setValueAtTime(0.35, t); noiseGain.gain.exponentialRampToValueAtTime(0.01, t+0.2);
                noise.start(t);

                // Kick Layer
                const osc2 = audioCtx.createOscillator(); const gain2 = audioCtx.createGain();
                osc2.connect(gain2); gain2.connect(audioCtx.destination);
                osc2.type = 'sine'; osc2.frequency.setValueAtTime(150, t); osc2.frequency.exponentialRampToValueAtTime(40, t+0.2);
                gain2.gain.setValueAtTime(0.3, t); gain2.gain.exponentialRampToValueAtTime(0.01, t+0.2);
                osc2.start(t); osc2.stop(t+0.2);

            } else if(type === 'SNIPER') {
                osc.type = 'square'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.5);
                gain.gain.setValueAtTime(0.2, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5); 
                osc.start(t); osc.stop(t + 0.5);
            }
        }

        function playImpactSound(type) {
            if(!audioCtx || audioCtx.state === 'suspended') return;
            const t = audioCtx.currentTime;
            
            // METEOR IMPACT / EXPLOSION
            const bufferSize = audioCtx.sampleRate * 0.5; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0); for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(500, t); filter.frequency.linearRampToValueAtTime(100, t+0.5);
            const gain = audioCtx.createGain();
            noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(0.4, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.5);
            noise.start(t);
        }

        function createGradientTexture(colorHex) {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createLinearGradient(0, 0, 0, 64);
            const col = new THREE.Color(colorHex);
            grd.addColorStop(0, col.clone().offsetHSL(0, 0, 0.2).getStyle());
            grd.addColorStop(1, col.clone().offsetHSL(0, 0, -0.1).getStyle());
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = "rgba(0,0,0,0.2)"; for(let i=0; i<64; i+=4) ctx.fillRect(0, i, 64, 1);
            return new THREE.CanvasTexture(canvas);
        }

        function createHpBarTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 16;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createLinearGradient(0, 0, 128, 0);
            grd.addColorStop(0, '#ff0000'); grd.addColorStop(0.5, '#ffff00'); grd.addColorStop(1, '#00ff00');
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 16);
            return new THREE.CanvasTexture(canvas);
        }

        function createBuildingTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#aaaaaa'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#666666'; 
            for(let y=8; y<128; y+=16) { for(let x=8; x<128; x+=16) { ctx.fillRect(x,y, 8, 8); } }
            ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 4; ctx.strokeRect(0,0,128,128);
            const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        function init() {
            try {
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(CONFIG.COLORS.BG, 0.015);
                scene.background = new THREE.Color(CONFIG.COLORS.BG);

                camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.copy(CAM_MODE.DEFAULT);
                camera.lookAt(0,0,0);

                renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                const renderPass = new RenderPass(scene, camera);
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.threshold = 0.1; bloom.strength = 1.8; bloom.radius = 0.5;
                
                glitchPass = new GlitchPass(); glitchPass.enabled = false; glitchPass.goWild = true;

                composer = new EffectComposer(renderer);
                composer.addPass(renderPass); composer.addPass(bloom); composer.addPass(glitchPass);

                world = new CANNON.World(); world.gravity.set(0, -60, 0);
                physMat = new CANNON.Material('slippery');
                world.addContactMaterial(new CANNON.ContactMaterial(physMat, physMat, { friction: 0.0, restitution: 0.0 }));

                const amb = new THREE.AmbientLight(0xffffff, 2.5); scene.add(amb);
                const sun = new THREE.DirectionalLight(0xffffff, 2.0);
                sun.position.set(20, 60, 20); sun.castShadow = true; scene.add(sun);

                // POOLING - OPTIMIZATION
                geoms.bulletSMG = new THREE.CapsuleGeometry(0.08, 0.8, 4, 8); geoms.bulletSMG.rotateX(-Math.PI/2);
                geoms.bulletShotgun = new THREE.SphereGeometry(0.2, 8, 8);
                geoms.bulletSniper = new THREE.CapsuleGeometry(0.15, 8.0, 4, 8); geoms.bulletSniper.rotateX(-Math.PI/2);
                geoms.enemyBullet = new THREE.BoxGeometry(0.2, 0.2, 1.0);
                geoms.meteor = new THREE.IcosahedronGeometry(2, 0); // Meteor Geometry
                geoms.particle = new THREE.BoxGeometry(0.1, 0.1, 0.1); // Firework particle
                
                // Enemy Geometries (Reused)
                geoms.scout = new THREE.ConeGeometry(0.8, 2, 4);
                geoms.rusher = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                geoms.heavy = new THREE.CylinderGeometry(1, 1, 2.5, 16);
                geoms.tyrant = new THREE.DodecahedronGeometry(1);
                geoms.elite = new THREE.IcosahedronGeometry(1);
                geoms.pyro = new THREE.OctahedronGeometry(1); 
                geoms.leech = new THREE.TetrahedronGeometry(1); 
                geoms.default = new THREE.OctahedronGeometry(1);

                geoms.hazardDot = new THREE.CircleGeometry(0.5, 8);

                // ADJUSTED NEON BRIGHTNESS FOR BULLETS (Slightly dimmer to prevent blow-out)
                mats.neonCyan = new THREE.MeshBasicMaterial({ color: 0x00cccc }); 
                mats.enemyBullet = new THREE.MeshBasicMaterial({ color: CONFIG.COLORS.SHOOTER });
                mats.hazardDot = new THREE.MeshBasicMaterial({color: 0xff0000, transparent: true, opacity: 0.8, side: THREE.DoubleSide});

                gradients['player'] = createGradientTexture(CONFIG.COLORS.NEON_CYAN);
                gradients['scout'] = createGradientTexture(CONFIG.COLORS.SCOUT);
                gradients['rusher'] = createGradientTexture(CONFIG.COLORS.RUSHER);
                gradients['heavy'] = createGradientTexture(CONFIG.COLORS.HEAVY);
                gradients['shooter'] = createGradientTexture(CONFIG.COLORS.SHOOTER);
                gradients['tyrant'] = createGradientTexture(0x444444);
                gradients['elite'] = createGradientTexture(CONFIG.COLORS.ELITE);
                gradients['pyro'] = createGradientTexture(CONFIG.COLORS.PYRO);
                gradients['leech'] = createGradientTexture(CONFIG.COLORS.LEECH);
                hpBarTexture = createHpBarTexture();
                buildingTexture = createBuildingTexture();

                createLevel();
                createPlayer();
                initInput();
                initMobileControls();
                updateAutoFireUI();

                document.getElementById('btn-start').addEventListener('click', startGame);
                document.getElementById('btn-restart').addEventListener('click', resetGame);
                document.getElementById('btn-resume').addEventListener('click', togglePause);
                document.getElementById('btn-restart-pause').addEventListener('click', () => { togglePause(); resetGame(); });
                document.getElementById('btn-music').addEventListener('click', toggleMusic);
                
                window.addEventListener('resize', onResize);

                clock = new THREE.Clock();
                
                const start = document.getElementById('start-screen');
                start.style.display = 'flex';
                composer.render();
                
                animate();

            } catch (e) { console.error(e); }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function highlightKey(key, active) {
            let id = '';
            if(key === 'w') id = 'key-w'; else if(key === 'a') id = 'key-a';
            else if(key === 's') id = 'key-s'; else if(key === 'd') id = 'key-d';
            else if(key === ' ') id = 'key-spc'; else if(key === 'f') id = 'key-f';
            else if(key === 'e') id = 'key-e'; else if(key === 'q') id = 'key-q';

            if(id) {
                const el = document.getElementById(id);
                if(el) {
                    if(active) el.classList.add('key-active');
                    else el.classList.remove('key-active');
                }
            }
        }

        function initInput() {
            window.addEventListener('keydown', e => {
                const k = e.key.toLowerCase();
                if(k === 'escape') { togglePause(); return; }
                if(STATE.paused) return; 

                highlightKey(k, true); 
                if(k==='w') keys.w=1; if(k==='a') keys.a=1; if(k==='s') keys.s=1; if(k==='d') keys.d=1;
                if(k===' ') handleDash();
                if(k==='r') handleReload();
                if(k==='f') handleMelee();
                if(k==='e') handleMolotov();
                if(k==='q') toggleAutoFire();
                if(k==='1') swap(0); if(k==='2') swap(1); if(k==='3') swap(2);
            });
            window.addEventListener('keyup', e => {
                const k = e.key.toLowerCase();
                highlightKey(k, false); 
                if(k==='w') keys.w=0; if(k==='a') keys.a=0; if(k==='s') keys.s=0; if(k==='d') keys.d=0;
            });
            window.addEventListener('mousedown', () => { if(!STATE.paused) keys.click=1; });
            window.addEventListener('mouseup', () => keys.click=0);
            window.addEventListener('mousemove', e => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                const cur = document.getElementById('custom-cursor');
                if(cur) { cur.style.left = e.clientX+'px'; cur.style.top = e.clientY+'px'; }
            });
        }

        function initMobileControls() {
            if('ontouchstart' in window) {
                STATE.mobile = true;
                const leftStick = document.getElementById('stick-left');
                const leftKnob = document.getElementById('knob-left');
                const rightStick = document.getElementById('stick-right');
                const rightKnob = document.getElementById('knob-right');
                const btnDash = document.getElementById('btn-dash');
                const btnMelee = document.getElementById('btn-melee');
                const btnMol = document.getElementById('btn-mol');
                
                let lCenter = {x:0, y:0};
                let rCenter = {x:0, y:0};
                
                leftStick.addEventListener('touchstart', e => {
                    const rect = leftStick.getBoundingClientRect();
                    lCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
                    updateStick(e.changedTouches[0], leftKnob, lCenter, true);
                });
                leftStick.addEventListener('touchmove', e => {
                    e.preventDefault();
                    updateStick(e.changedTouches[0], leftKnob, lCenter, true);
                });
                leftStick.addEventListener('touchend', () => {
                    leftKnob.style.transform = `translate(-50%, -50%)`;
                    keys.w = 0; keys.a = 0; keys.s = 0; keys.d = 0;
                });

                rightStick.addEventListener('touchstart', e => {
                    const rect = rightStick.getBoundingClientRect();
                    rCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
                    updateStick(e.changedTouches[0], rightKnob, rCenter, false);
                    keys.click = 1; 
                });
                rightStick.addEventListener('touchmove', e => {
                    e.preventDefault();
                    updateStick(e.changedTouches[0], rightKnob, rCenter, false);
                });
                rightStick.addEventListener('touchend', () => {
                    rightKnob.style.transform = `translate(-50%, -50%)`;
                    keys.click = 0;
                });

                btnDash.addEventListener('touchstart', (e) => { e.preventDefault(); handleDash(); });
                btnMelee.addEventListener('touchstart', (e) => { e.preventDefault(); handleMelee(); });
                btnMol.addEventListener('touchstart', (e) => { e.preventDefault(); handleMolotov(); });
            }
        }

        function updateStick(touch, knob, center, isMove) {
            const dx = touch.clientX - center.x;
            const dy = touch.clientY - center.y;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 50);
            const angle = Math.atan2(dy, dx);
            
            const kx = Math.cos(angle) * dist;
            const ky = Math.sin(angle) * dist;
            
            knob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;
            
            if(isMove) {
                keys.d = (dx > 10) ? 1 : 0; keys.a = (dx < -10) ? 1 : 0; keys.s = (dy > 10) ? 1 : 0; keys.w = (dy < -10) ? 1 : 0;
            } else {
                mouse.x = Math.cos(angle) * 0.5; mouse.y = -Math.sin(angle) * 0.5;
            }
        }

        function toggleAutoFire() {
            STATE.autoFireActive = !STATE.autoFireActive;
            updateAutoFireUI();
        }

        function updateAutoFireUI() {
            const st = document.getElementById('q-status');
            const el = document.getElementById('key-q');
            if(STATE.autoFireActive) {
                st.innerText = "ON";
                if(el) el.classList.add('key-active'); 
            } else {
                st.innerText = "OFF";
                if(el) el.classList.remove('key-active');
            }
        }

        function showNotification(text) {
            const zone = document.getElementById('notification-zone');
            const card = document.createElement('div');
            card.className = 'notif-card'; card.innerText = text;
            zone.appendChild(card);
            setTimeout(() => card.remove(), 2000); 
        }

        function createLevel() {
            const geo = new THREE.PlaneGeometry(160, 160);
            const mat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2; mesh.receiveShadow = true;
            scene.add(mesh);

            const grid = new THREE.GridHelper(150, 75, 0xffffff, 0x444444);
            grid.position.y = 0.05; scene.add(grid);
            STATE.grid = grid;

            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: physMat });
            body.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            world.addBody(body);

            const wShape = new CANNON.Box(new CANNON.Vec3(75, 10, 1));
            const walls = [[0,5,-75],[0,5,75],[-75,5,0,Math.PI/2],[75,5,0,Math.PI/2]];
            walls.forEach(p => {
                const b = new CANNON.Body({ mass:0, position:new CANNON.Vec3(p[0],p[1],p[2]) });
                b.addShape(wShape);
                if(p[3]) b.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), p[3]);
                world.addBody(b);
            });

            regenerateMap();
        }

        function regenerateMap() {
            STATE.mapGlitching = true; STATE.glitchTimer = 1.0;
            dynamicProps.forEach(p => { scene.remove(p.mesh); world.removeBody(p.body); });
            dynamicProps = [];
            if(STATE.isRunning) showNotification("MAP RECONFIGURING");

            for(let i=0; i<40; i++) { 
                const x = (Math.random()-0.5)*130;
                const z = (Math.random()-0.5)*130;
                if(Math.abs(x)<15 && Math.abs(z)<15) continue;
                if(playerMesh && new THREE.Vector3(x,0,z).distanceTo(playerMesh.position) < 10) continue;

                const w = Math.random()*6+4; const h = Math.random()*8+4;
                const b = new CANNON.Body({ mass:0, position:new CANNON.Vec3(x,h/2,z), material:physMat });
                b.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,w/2))); 
                world.addBody(b);
                
                const geo = new THREE.BoxGeometry(w, h, w);
                const mat = new THREE.MeshStandardMaterial({
                    map: buildingTexture, emissive: 0xaaaaaa, emissiveMap: buildingTexture,
                    emissiveIntensity: 2.0, color: 0x888888 
                });
                
                const m = new THREE.Mesh(geo, mat);
                m.position.set(x, h/2, z); m.castShadow = true; m.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(m);
                gsap.to(m.material, { emissiveIntensity: 0.1, duration: 1.0, ease: "power2.out" });

                scene.add(m);
                dynamicProps.push({body:b, mesh:m, originalScale: m.scale.clone(), box: box});
            }
        }

        function createPlayer() {
            playerBody = new CANNON.Body({ mass: 60, position: new CANNON.Vec3(0, 2, 0), shape: new CANNON.Sphere(1), material: physMat, fixedRotation: true, linearDamping: 0.9 });
            world.addBody(playerBody);

            playerMesh = new THREE.Group();
            const armorMat = new THREE.MeshStandardMaterial({ color: 0x88aaff, metalness: 0.9, roughness: 0.1 });
            const jointMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            // ADJUSTED NEON INTENSITY ON PLAYER (Reduced from 8.0)
            const neonMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 2.5 });

            playerMesh.scale.setScalar(1.3);

            const ringGeo = new THREE.RingGeometry(1.2, 1.5, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2; ring.position.y = 0.1;
            playerMesh.add(ring);

            const hips = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.4, 0.5), armorMat); hips.position.y = 0.8; playerMesh.add(hips);

            const legGeo = new THREE.BoxGeometry(0.35, 0.8, 0.4);
            const legL = new THREE.Group(); legL.position.set(-0.25, 0, 0); 
            const legLMesh = new THREE.Mesh(legGeo, armorMat); legLMesh.position.y = -0.4; legL.add(legLMesh); hips.add(legL);

            const legR = new THREE.Group(); legR.position.set(0.25, 0, 0); 
            const legRMesh = new THREE.Mesh(legGeo, armorMat); legRMesh.position.y = -0.4; legR.add(legRMesh); hips.add(legR);

            const torso = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.8, 0.7), armorMat); torso.position.y = 1.5; torso.castShadow = true; playerMesh.add(torso);
            const core = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8), neonMat); core.rotation.x = Math.PI/2; core.position.set(0, 1.5, 0.36); playerMesh.add(core);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.6), armorMat); head.position.y = 2.2; playerMesh.add(head);
            const visor = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.15, 0.1), neonMat); visor.position.set(0, 0, 0.31); head.add(visor);

            const shoulderGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const shoulderL = new THREE.Mesh(shoulderGeo, armorMat); shoulderL.position.set(-0.7, 1.7, 0); playerMesh.add(shoulderL);
            const shoulderR = new THREE.Mesh(shoulderGeo, armorMat); shoulderR.position.set(0.7, 1.7, 0); playerMesh.add(shoulderR);

            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), jointMat); armR.position.set(0, -0.4, 0); shoulderR.add(armR);
            const gunGrp = new THREE.Group(); gunGrp.position.set(0, -0.3, 0.3); armR.add(gunGrp);
            const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 1.5), new THREE.MeshStandardMaterial({color: 0x444444})); gunBody.position.set(0, 0, 0.4); gunGrp.add(gunBody);
            const gunBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1.6), neonMat); gunBarrel.position.set(0, 0.1, 0.5); gunGrp.add(gunBarrel);
            const gunTip = new THREE.Object3D(); gunTip.position.set(0, 0, 0.8); gunBarrel.add(gunTip);

            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), jointMat); armL.position.set(0, -0.4, 0); shoulderL.add(armL);
            const fistL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), armorMat); fistL.position.set(0, -0.4, 0); armL.add(fistL);

            const pl = new THREE.PointLight(0x00ffff, 4, 30); pl.position.set(0, 3, 0); playerMesh.add(pl);

            playerMesh.userData = { visor, neonMat, gunTip, torso, core, legL, legR };
            scene.add(playerMesh);
        }

        function updatePlayer() {
            if(!STATE.isRunning || STATE.paused || PLAYER.hp <= 0) return;

            if(PLAYER.frozenTimer > 0) {
                PLAYER.frozenTimer -= delta;
                document.getElementById('frost-overlay').classList.remove('hidden');
                if(playerMesh.userData.neonMat) playerMesh.userData.neonMat.color.setHex(0xffffff);
                return; 
            } else {
                document.getElementById('frost-overlay').classList.add('hidden');
                if(playerMesh.userData.neonMat) playerMesh.userData.neonMat.color.setHex(0x00ffff);
            }

            let speedMod = 1.0;
            if(PLAYER.leechSlowTimer > 0) {
                PLAYER.leechSlowTimer -= delta; speedMod = 0.7; 
                document.getElementById('slowed-label').style.display = 'block';
            } else {
                document.getElementById('slowed-label').style.display = 'none';
            }

            const input = new THREE.Vector3(keys.d-keys.a, 0, keys.s-keys.w).normalize();
            let spd = PLAYER.dashCd ? CONFIG.SPEED_DASH : CONFIG.SPEED_BASE;
            spd *= speedMod;
            
            playerBody.velocity.x = input.x * spd;
            playerBody.velocity.z = input.z * spd;

            if(input.lengthSq() > 0.1) {
                const walkSpeed = 15;
                playerMesh.userData.legL.rotation.x = Math.sin(STATE.time * walkSpeed) * 0.5;
                playerMesh.userData.legR.rotation.x = Math.sin(STATE.time * walkSpeed + Math.PI) * 0.5;
            } else {
                playerMesh.userData.legL.rotation.x = 0; playerMesh.userData.legR.rotation.x = 0;
            }

            const tiltX = playerBody.velocity.z * 0.005;
            const tiltZ = -playerBody.velocity.x * 0.005;
            gsap.to(playerMesh.rotation, { x: tiltX, z: tiltZ, duration: 0.2 });

            const isSniper = (PLAYER.wepIdx === 2);
            const camOffset = isSniper ? CAM_MODE.SNIPER : CAM_MODE.DEFAULT;

            const targetPos = new THREE.Vector3(
                playerMesh.position.x + camOffset.x,
                camOffset.y,
                playerMesh.position.z + camOffset.z
            );
            
            camera.position.lerp(targetPos, 0.05); 
            camera.lookAt(playerMesh.position); 

            playerMesh.position.copy(playerBody.position);
            playerMesh.position.y -= 1;
            
            if(STATE.mobile) {
                if(Math.abs(mouse.x) > 0.01 || Math.abs(mouse.y) > 0.01) {
                    const aimTarget = playerMesh.position.clone().add(new THREE.Vector3(mouse.x*10, 0, mouse.y*10));
                    playerMesh.lookAt(aimTarget.x, playerMesh.position.y, aimTarget.z);
                }
            } else {
                raycaster.setFromCamera(mouse, camera);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(groundPlane, target);
                playerMesh.lookAt(target.x, playerMesh.position.y, target.z);
            }

            if(PLAYER.sp < PLAYER.maxSp && !PLAYER.dashCd) PLAYER.sp += 15 * delta;
            
            if(PLAYER.molotovCharges < PLAYER.molotovMaxCharges) {
                PLAYER.molotovRecharge += delta;
                if(PLAYER.molotovRecharge >= PLAYER.molotovRechargeTime) {
                    PLAYER.molotovCharges++; PLAYER.molotovRecharge = 0; updateHUD();
                }
                const pct = (PLAYER.molotovRecharge / PLAYER.molotovRechargeTime) * 100;
                document.getElementById('bar-molotov').style.width = pct + '%';
            } else {
                document.getElementById('bar-molotov').style.width = '100%';
            }

            if(PLAYER.isDashing) {
                PLAYER.dashTimer -= delta;
                if(PLAYER.dashTimer % 0.05 < delta) { 
                    const ghost = playerMesh.clone();
                    ghost.position.copy(playerMesh.position); ghost.rotation.copy(playerMesh.rotation); ghost.scale.copy(playerMesh.scale);
                    ghost.traverse(c => { if(c.isMesh) c.material = new THREE.MeshBasicMaterial({color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.3}); });
                    scene.add(ghost);
                    gsap.to(ghost.material, {opacity: 0, duration: 0.3, onComplete: () => scene.remove(ghost)});
                }
            }
        }

        function handleDash() {
            if(PLAYER.dashCd || PLAYER.sp < 10 || PLAYER.frozenTimer > 0) return;
            playSound('dash');
            PLAYER.dashCd = true; PLAYER.sp -= 10; PLAYER.isDashing = true; PLAYER.dashTimer = 0.2; 
            setTimeout(() => { PLAYER.dashCd = false; PLAYER.isDashing = false; }, 200);
        }

        function handleShooting() {
            if(!STATE.isRunning || STATE.paused || PLAYER.frozenTimer > 0) return;
            const w = WEAPONS[PLAYER.wepIdx];
            const trigger = keys.click || STATE.autoFireActive;
            
            if(trigger && !PLAYER.reloading && STATE.time > (w.lastShot || 0) + w.rate) {
                if(w.ammo > 0) {
                    w.ammo--; w.lastShot = STATE.time;
                    playGunSound(w.name);
                    
                    let dir;
                    if(STATE.mobile) {
                        dir = new THREE.Vector3(mouse.x, 0, mouse.y).normalize();
                        if(dir.lengthSq() < 0.1) {
                           const temp = new THREE.Vector3(0,0,1); temp.applyQuaternion(playerMesh.quaternion); dir = temp;
                        }
                    } else {
                        raycaster.setFromCamera(mouse, camera);
                        const target = new THREE.Vector3(); raycaster.ray.intersectPlane(groundPlane, target);
                        const origin = new THREE.Vector3(); playerMesh.userData.gunTip.getWorldPosition(origin);
                        dir = new THREE.Vector3().subVectors(target, origin).normalize(); dir.y = 0;
                    }

                    const origin = new THREE.Vector3(); playerMesh.userData.gunTip.getWorldPosition(origin);
                    const cnt = w.pellets || 1;
                    
                    for(let i=0; i<cnt; i++) {
                        const spread = (Math.random()-0.5) * w.spread;
                        const finalDir = dir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), spread);
                        spawnBullet(origin, finalDir, w.dmg, true, PLAYER.wepIdx);
                    }

                    const ammoDiv = document.getElementById('ammo-cur');
                    ammoDiv.classList.remove('shake-effect'); void ammoDiv.offsetWidth; ammoDiv.classList.add('shake-effect');
                    updateHUD();
                } else {
                    handleReload();
                }
            }
        }

        function spawnBullet(pos, dir, dmg, isPlayer, wepIdx) {
            const isSniper = (isPlayer && wepIdx === 2);
            let mesh, spd;

            if (isPlayer) {
                const neonMat = mats.neonCyan; 
                if (wepIdx === 0) { mesh = new THREE.Mesh(geoms.bulletSMG, neonMat); spd = 90; }
                else if (wepIdx === 1) { mesh = new THREE.Mesh(geoms.bulletShotgun, neonMat); spd = 70; }
                else { mesh = new THREE.Mesh(geoms.bulletSniper, neonMat); spd = 200; }
            } else {
                mesh = new THREE.Mesh(geoms.enemyBullet, mats.enemyBullet); spd = 35;
            }
            
            mesh.position.copy(pos); mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), dir);
            scene.add(mesh);
            const arr = isPlayer ? bullets : enemyBullets;
            arr.push({ mesh:mesh, vel:dir.multiplyScalar(spd), dmg, life:2.0, piercing: isSniper, hitIds: [], wepIdx: isPlayer ? wepIdx : -1 });
        }

        function handleMelee() {
            if(PLAYER.sp < 8 || PLAYER.frozenTimer > 0) return;
            playSound('melee');
            PLAYER.sp -= 8;

            if(PLAYER.leechAttached) {
                PLAYER.leechAttached = false;
                if(attachedLeechMesh) { scene.remove(attachedLeechMesh); attachedLeechMesh = null; }
                document.getElementById('leech-warning').style.display = 'none';
            }

            gsap.to(playerMesh.rotation, {y: playerMesh.rotation.y + Math.PI*2, duration: 0.2});

            const waveGeo = new THREE.RingGeometry(5, 6, 64);
            const waveMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, opacity: 1.0, transparent: true, depthTest: false });
            const wave = new THREE.Mesh(waveGeo, waveMat);
            wave.rotation.x = -Math.PI/2; wave.position.copy(playerMesh.position); wave.position.y = 1.0;
            scene.add(wave);
            
            wave.scale.set(0, 0, 0);
            gsap.to(wave.scale, {x: 1.5, y: 1.5, duration: 0.2});
            gsap.to(wave.material, {opacity: 0, duration: 0.2, onComplete: () => scene.remove(wave)});

            const range = 9;
            enemies.forEach(e => {
                if(playerMesh.position.distanceTo(e.mesh.position) < range) {
                    e.hp -= 60;
                    const knockDir = new CANNON.Vec3().copy(e.body.position).vsub(playerBody.position);
                    knockDir.normalize();
                    e.body.velocity.set(knockDir.x*60, 5, knockDir.z*60); 
                    if(e.hp<=0) killEnemy(e);
                }
            });
        }

        function handleMolotov() {
            if(PLAYER.molotovCharges <= 0 || PLAYER.frozenTimer > 0) return;
            PLAYER.molotovCharges--; updateHUD();

            playImpactSound('molotov'); 

            let target;
            if(STATE.mobile) {
                target = playerMesh.position.clone().add(new THREE.Vector3(0,0,5).applyQuaternion(playerMesh.quaternion));
            } else {
                raycaster.setFromCamera(mouse, camera);
                target = new THREE.Vector3(); raycaster.ray.intersectPlane(groundPlane, target);
            }

            const zone = new THREE.Mesh(new THREE.CircleGeometry(8, 32), new THREE.MeshBasicMaterial({color:0xff4400, side:THREE.DoubleSide, transparent:true, opacity:0.6}));
            zone.rotation.x = -Math.PI/2; zone.position.copy(target); zone.position.y = 0.1;
            scene.add(zone);
            fireZones.push({ mesh:zone, pos:target, life:5.0 });
        }

        function spawnEnemy() {
            if(!STATE.isRunning || STATE.paused || enemies.length > maxEnemies) return; 

            let x, z;
            let valid = false; let attempts = 0; const minSpawnDist = 30; 
            while(!valid && attempts < 15) {
                x = (Math.random() - 0.5) * 120; z = (Math.random() - 0.5) * 120;
                if(new THREE.Vector3(x,0,z).distanceTo(playerMesh.position) > minSpawnDist) valid = true;
                attempts++;
            }
            if(!valid) return;

            const rnd = Math.random();
            let type = 'rusher';
            if(rnd > 0.98) type = 'leech'; 
            else if(rnd > 0.96) type = 'elite'; 
            else if(rnd > 0.94) type = 'pyro'; 
            else if(rnd > 0.90) type = 'tyrant';
            else if(rnd > 0.85) type = 'heavy';
            else if(rnd > 0.65) type = 'shooter';
            else if(rnd > 0.35) type = 'scout';

            const st = {
                scout: { spd: 60, hp: 20, col: CONFIG.COLORS.SCOUT, scl: 0.8, dmg: 1, range: 1.5, rate: 0.8 }, 
                rusher: { spd: 42, hp: 45, col: CONFIG.COLORS.RUSHER, scl: 1.2, dmg: 3, range: 2, rate: 0.8 },
                heavy: { spd: 24, hp: 120, col: CONFIG.COLORS.HEAVY, scl: 1.8, dmg: 7, range: 2.5, rate: 0.8 },
                shooter: { spd: 33, hp: 35, col: CONFIG.COLORS.SHOOTER, scl: 1.0, dmg: 3, range: 20, rate: 0.3 }, 
                tyrant: { spd: 66, hp: 200, col: CONFIG.COLORS.TYRANT, scl: 2.5, dmg: 5, range: 2, rate: 0.8 },
                elite: { spd: 50, hp: 80, col: CONFIG.COLORS.ELITE, scl: 1.3, dmg: 1, range: 20, rate: 0.15 },
                pyro: { spd: 25, hp: 60, col: CONFIG.COLORS.PYRO, scl: 1.1, dmg: 0, range: 25, rate: 3.0 },
                leech: { spd: 80, hp: 10, col: CONFIG.COLORS.LEECH, scl: 0.5, dmg: 0, range: 15, rate: 0.5 } 
            }[type];

            const body = new CANNON.Body({ mass: 5, position: new CANNON.Vec3(x, 2, z), fixedRotation: true });
            body.addShape(new CANNON.Cylinder(0.8*st.scl, 0.8*st.scl, 2*st.scl, 8));
            world.addBody(body);

            const grp = new THREE.Group();
            
            let geo;
            if(type==='scout') geo = geoms.scout;
            else if(type==='rusher') geo = geoms.rusher;
            else if(type==='heavy') geo = geoms.heavy;
            else if(type==='tyrant') geo = geoms.tyrant;
            else if(type==='elite') geo = geoms.elite;
            else if(type==='pyro') geo = geoms.pyro; 
            else if(type==='leech') geo = geoms.leech; 
            else geo = geoms.default;

            const mat = new THREE.MeshStandardMaterial({ 
                map: gradients[type], emissive: st.col, emissiveMap: gradients[type], emissiveIntensity: 1.0, roughness: 0.2
            });
            const m = new THREE.Mesh(geo, mat); m.scale.setScalar(st.scl);
            
            if(['tyrant','heavy','elite','pyro','leech'].includes(type)) {
                const l = new THREE.PointLight(st.col, 1, 8); m.add(l);
            }

            const barGeo = new THREE.PlaneGeometry(1.5 * st.scl, 0.2);
            const barMat = new THREE.MeshBasicMaterial({ map: hpBarTexture });
            const bar = new THREE.Mesh(barGeo, barMat); bar.position.y = 2 * st.scl;
            
            const bgGeo = new THREE.PlaneGeometry(1.6 * st.scl, 0.3);
            const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const bg = new THREE.Mesh(bgGeo, bgMat); bg.position.y = 2 * st.scl; bg.position.z = -0.01;

            grp.add(bg); grp.add(bar); grp.add(m); 
            grp.position.set(x, 0, z); scene.add(grp);
            enemies.push({ mesh:grp, body, hp:st.hp, max:st.hp, type, st, lastAtk:0, hpBar: bar });
        }

        function killEnemy(e) {
            scene.remove(e.mesh); world.removeBody(e.body);
            spawnLoot(e.mesh.position);
            const idx = enemies.indexOf(e);
            if(idx > -1) enemies.splice(idx, 1);
        }

        function updateEntities() {
            // FIRE ZONES
            for(let i=fireZones.length-1; i>=0; i--) {
                const z = fireZones[i];
                z.life -= delta;
                if(z.life <= 0) { scene.remove(z.mesh); fireZones.splice(i,1); continue; }
                
                if(z.isPlayerOwned !== false) { // Default true
                    enemies.forEach(e => {
                        if(e.mesh.position.distanceTo(z.pos) < 7) {
                            e.hp -= 30 * delta; if(e.hp<=0) killEnemy(e);
                        }
                    });
                } else {
                    if(playerMesh.position.distanceTo(z.pos) < 7) hitPlayer(3 * delta); 
                }
                z.mesh.material.opacity = 0.4 + Math.random()*0.4;
            }

            // BULLETS
            for(let i=bullets.length-1; i>=0; i--) {
                const b = bullets[i];
                b.life -= delta; b.mesh.position.add(b.vel.clone().multiplyScalar(delta));
                
                let hitProp = false;
                for(let p of dynamicProps) {
                    if(p.box.containsPoint(b.mesh.position)) { hitProp = true; break; }
                }
                if(!b.piercing && hitProp) { scene.remove(b.mesh); bullets.splice(i,1); continue; }

                let hit = false;
                for(let e of enemies) {
                    if(b.mesh.position.distanceTo(e.mesh.position) < 2.5 * e.st.scl) {
                        if(b.piercing) {
                            if(!b.hitIds.includes(e.body.id)) {
                                e.hp -= b.dmg; b.hitIds.push(e.body.id);
                                playHitSound(b.wepIdx); // WEAPON SPECIFIC HIT SOUND
                                e.mesh.children[2].material.emissiveIntensity = 5.0; 
                                setTimeout(() => { if(e.mesh) e.mesh.children[2].material.emissiveIntensity = 1.0; }, 50);
                                if(e.hp <= 0) killEnemy(e);
                            }
                        } else {
                            e.hp -= b.dmg; hit = true;
                            playHitSound(b.wepIdx); // WEAPON SPECIFIC HIT SOUND
                            e.mesh.children[2].material.emissiveIntensity = 5.0;
                            setTimeout(() => { if(e.mesh) e.mesh.children[2].material.emissiveIntensity = 1.0; }, 50);
                            if(e.hp <= 0) killEnemy(e);
                            break;
                        }
                    }
                }
                if((hit && !b.piercing) || b.life <= 0) { scene.remove(b.mesh); bullets.splice(i,1); }
            }

            // ENEMY BULLETS
            for(let i=enemyBullets.length-1; i>=0; i--) {
                const b = enemyBullets[i];
                b.life -= delta; b.mesh.position.add(b.vel.clone().multiplyScalar(delta));
                if(b.mesh.position.distanceTo(playerMesh.position) < 2.5) {
                    hitPlayer(b.dmg); scene.remove(b.mesh); enemyBullets.splice(i,1); continue;
                }
                if(b.life <= 0) { scene.remove(b.mesh); enemyBullets.splice(i,1); }
            }

            // PROJECTILES
            for(let i=enemyProjectiles.length-1; i>=0; i--) {
                const p = enemyProjectiles[i];
                p.progress += delta * 1.0; 
                const currentPos = new THREE.Vector3().lerpVectors(p.start, p.target, p.progress);
                currentPos.y += Math.sin(p.progress * Math.PI) * 10; 
                p.mesh.position.copy(currentPos); p.mesh.rotation.x += delta * 5; p.mesh.rotation.z += delta * 5;

                if(p.progress >= 1) {
                    scene.remove(p.mesh); enemyProjectiles.splice(i,1);
                    const zone = new THREE.Mesh(new THREE.CircleGeometry(8, 32), new THREE.MeshBasicMaterial({color:0xff0044, side:THREE.DoubleSide, transparent:true, opacity:0.6}));
                    zone.rotation.x = -Math.PI/2; zone.position.copy(p.target); zone.position.y = 0.1;
                    scene.add(zone);
                    fireZones.push({ mesh:zone, pos:p.target, life:5.0, isPlayerOwned: false });
                }
            }

            const pPos = playerMesh.position;
            enemies.forEach(e => {
                e.hpBar.scale.x = Math.max(0, e.hp / e.max); e.hpBar.lookAt(camera.position); 

                const dist = pPos.distanceTo(e.mesh.position);
                const dir = new CANNON.Vec3().copy(playerBody.position).vsub(e.body.position);
                dir.y = 0; dir.normalize();

                let move = true;
                if(e.type === 'leech') {
                    if(dist < 15 && !PLAYER.leechAttached) {
                        e.body.velocity.set(dir.x*80, 5, dir.z*80); move = false;
                        if(dist < 2.0) { attachLeech(); killEnemy(e); return; }
                    }
                } else if(dist < e.st.range) {
                    move = false;
                    if(e.type !== 'shooter' && e.type !== 'elite' && e.type !== 'pyro' && STATE.time > e.lastAtk + 0.8) {
                        e.lastAtk = STATE.time; hitPlayer(e.st.dmg);
                    }
                }

                if(e.type === 'shooter' && dist < e.st.range) {
                    move = false; e.body.velocity.set(0,0,0);
                    if(STATE.time > e.lastAtk + e.st.rate) { 
                        e.lastAtk = STATE.time;
                        const sDir = new THREE.Vector3().subVectors(pPos, e.mesh.position).normalize();
                        spawnBullet(e.mesh.position.clone().add(new THREE.Vector3(0,2,0)), sDir, e.st.dmg, false);
                    }
                }
                
                if(e.type === 'elite' && dist < e.st.range) {
                    move = false; e.body.velocity.set(0,0,0);
                    if(STATE.time > e.lastAtk + e.st.rate) {
                        e.lastAtk = STATE.time;
                        const sDir = new THREE.Vector3().subVectors(pPos, e.mesh.position).normalize();
                        const origin = e.mesh.position.clone().add(new THREE.Vector3(0,2,0));
                        for(let i=0; i<3; i++) {
                            const spread = (Math.random()-0.5) * 0.3;
                            const finalDir = sDir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), spread);
                            spawnBullet(origin, finalDir, e.st.dmg, false);
                        }
                    }
                }

                if(e.type === 'pyro' && dist < e.st.range) {
                    move = false; e.body.velocity.set(0,0,0);
                    if(STATE.time > e.lastAtk + e.st.rate) {
                        e.lastAtk = STATE.time;
                        const mGeo = new THREE.DodecahedronGeometry(0.5);
                        const mMat = new THREE.MeshBasicMaterial({color: 0xff4444});
                        const mMesh = new THREE.Mesh(mGeo, mMat);
                        mMesh.position.copy(e.mesh.position).add(new THREE.Vector3(0,2,0));
                        scene.add(mMesh);
                        enemyProjectiles.push({ mesh: mMesh, start: mMesh.position.clone(), target: pPos.clone(), progress: 0 });
                    }
                }

                if(move) {
                    e.body.velocity.x = dir.x * e.st.spd; e.body.velocity.z = dir.z * e.st.spd;
                }
                e.mesh.lookAt(pPos); e.mesh.position.copy(e.body.position); e.mesh.position.y -= 1; e.mesh.quaternion.copy(e.body.quaternion);
            });
        }

        function attachLeech() {
            if(PLAYER.leechAttached) return;
            PLAYER.leechAttached = true; PLAYER.leechSlowTimer = 1000;
            document.getElementById('leech-warning').style.display = 'block';
            attachedLeechMesh = new THREE.Mesh(new THREE.TetrahedronGeometry(0.5), new THREE.MeshBasicMaterial({color: CONFIG.COLORS.LEECH}));
            attachedLeechMesh.position.set(0, 1, 0.5); playerMesh.add(attachedLeechMesh);
        }

        function updateParticles() {
            if(STATE.grid) { const scale = 1 + Math.sin(STATE.time * 2) * 0.02; STATE.grid.scale.set(scale, 1, scale); }

            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i]; p.life -= delta;
                
                // Hazard Dot Logic (Fade Out)
                if(p.type === 'hazard_dot') {
                    p.mesh.material.opacity = p.life; 
                    if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i,1); }
                    continue; 
                }

                if(p.type === 'firework') {
                    p.mesh.position.add(p.vel);
                    p.vel.y -= 0.02; // Gravity
                    p.mesh.material.opacity = p.life;
                    if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i,1); }
                    continue;
                }

                if (p.vel instanceof THREE.Vector3) p.mesh.position.add(p.vel.clone().multiplyScalar(delta));
                
                if(p.type === 'scar') {
                    if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i,1); } continue;
                }

                if (p.type === 'snow' || p.type === 'fire') {
                    if (p.mesh.position.y <= 0) {
                        playImpactSound(); 
                        if(p.type === 'snow') {
                            showNotification("FROST IMPACT");
                            if(playerMesh.position.distanceTo(p.mesh.position) < 10) { hitPlayer(4); PLAYER.frozenTimer = 0.5; }
                        } else {
                            if(playerMesh.position.distanceTo(p.mesh.position) < 12) hitPlayer(30);
                        }
                        scene.remove(p.mesh); 
                        // Explosion visual
                        const wave = new THREE.Mesh(new THREE.RingGeometry(1, 15, 32), new THREE.MeshBasicMaterial({color: p.type === 'snow' ? 0x00ffff : 0xffaa00, transparent: true, opacity: 0.5}));
                        wave.rotation.x = -Math.PI/2; wave.position.set(p.mesh.position.x, 0.2, p.mesh.position.z);
                        scene.add(wave);
                        gsap.to(wave.scale, {x:1.5, y:1.5, duration:0.3});
                        gsap.to(wave.material, {opacity:0, duration:0.3, onComplete:()=>scene.remove(wave)});

                        particles.splice(i,1); continue;
                    }
                } else {
                    p.vel.y -= 25 * delta; p.mesh.rotation.x += delta * 5;
                }
                if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i,1); }
            }
        }

        function spawnFirework() {
            const x = (Math.random()-0.5) * 100;
            const z = (Math.random()-0.5) * 100;
            const y = 30 + Math.random() * 20;
            const color = Math.random() > 0.5 ? 0xff00ff : 0x00ff00;
            
            for(let i=0; i<20; i++) {
                const m = new THREE.Mesh(geoms.particle, new THREE.MeshBasicMaterial({color: color, transparent: true}));
                m.position.set(x, y, z);
                const vel = new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);
                scene.add(m);
                particles.push({mesh:m, vel:vel, life: 1.0 + Math.random(), type:'firework'});
            }
        }

        function updateMeteors() {
            if(!STATE.hellRain && STATE.time > STATE.lastMeteor + 3) { 
                STATE.hellRain = true; STATE.lastMeteor = STATE.time;
                showNotification("METEOR DETECTED");
                let count = 0; let maxMeteors = 5 + (STATE.level * 1); 
                const barrage = setInterval(() => {
                    if(STATE.paused || !STATE.isRunning) { clearInterval(barrage); STATE.hellRain = false; return; }
                    const type = Math.random() > 0.5 ? 'fire' : 'snow';
                    spawnMeteor(type); count++;
                    if(count > maxMeteors) { clearInterval(barrage); STATE.hellRain = false; }
                }, 300); 
            }
        }

        function spawnMeteor(type) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 10 + Math.random() * 25; 
            const x = playerMesh.position.x + Math.cos(angle) * dist;
            const z = playerMesh.position.z + Math.sin(angle) * dist;
            
            const col = type === 'fire' ? 0xff4400 : 0x00ffff;
            const m = new THREE.Mesh(geoms.meteor, new THREE.MeshStandardMaterial({color: col, emissive: col, emissiveIntensity: 2.0, wireframe: true}));
            m.position.set(x, 50, z); scene.add(m);

            particles.push({ mesh: m, life: 5.0, type: type, vel: new THREE.Vector3(0, -40, 0) });
        }

        function spawnLoot(pos) {
            if(Math.random()>0.7) return; 
            const type = Math.random()>0.7 ? 'hp' : 'ammo';
            const col = type==='hp' ? 0x00ff00 : 0x0088ff;
            const geo = type==='hp' ? new THREE.BoxGeometry(0.8, 0.8, 0.8) : new THREE.OctahedronGeometry(0.5);
            const m = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:col, wireframe:true}));
            m.position.copy(pos); m.position.y = 1; scene.add(m);
            loot.push({mesh:m, type, life: type==='hp' ? 25 : 30});
        }

        function checkLoot() {
            for(let i=loot.length-1; i>=0; i--) {
                const l = loot[i];
                l.mesh.rotation.y += delta * 3; l.life -= delta;
                if(l.life < 3) l.mesh.visible = Math.floor(STATE.time * 10) % 2 === 0;
                if(l.life <= 0) { scene.remove(l.mesh); loot.splice(i,1); continue; }
                if(playerMesh.position.distanceTo(l.mesh.position) < 3.5) {
                    let taken = false;
                    if(l.type==='hp') { if(PLAYER.hp < PLAYER.maxHp) { PLAYER.hp = Math.min(PLAYER.hp+25, 100); taken = true; } } 
                    else { WEAPONS.forEach(wp => wp.ammo = Math.min(wp.ammo + Math.floor(wp.max*0.5), wp.max)); taken = true; }
                    if(taken) { scene.remove(l.mesh); loot.splice(i,1); updateHUD(); }
                }
            }
        }

        function handleReload() {
            if(PLAYER.reloading) return;
            playSound('reload'); 
            PLAYER.reloading = true;
            
            const isSniper = PLAYER.wepIdx === 2;
            const reloadTime = isSniper ? 1600 : 800; 

            const barBg = document.getElementById('reload-bar-bg');
            const barFill = document.getElementById('reload-bar-fill');
            barBg.style.display = 'block'; barFill.style.transition = 'none'; barFill.style.width = '0%';
            const ammoTxt = document.getElementById('ammo-cur'); ammoTxt.classList.add('reloading-text');
            void barFill.offsetWidth;
            
            barFill.style.transition = `width ${reloadTime/1000}s linear`; 
            barFill.style.width = '100%';

            setTimeout(() => {
                if(!STATE.paused) {
                    WEAPONS[PLAYER.wepIdx].ammo = WEAPONS[PLAYER.wepIdx].max;
                    PLAYER.reloading = false; barBg.style.display = 'none'; ammoTxt.classList.remove('reloading-text'); updateHUD();
                } else {
                    WEAPONS[PLAYER.wepIdx].ammo = WEAPONS[PLAYER.wepIdx].max;
                    PLAYER.reloading = false; barBg.style.display = 'none'; ammoTxt.classList.remove('reloading-text'); updateHUD();
                }
            }, reloadTime);
        }

        function hitPlayer(dmg) {
            PLAYER.hp -= dmg; updateHUD(); if(PLAYER.hp <= 0) gameOver();
        }

        function updateHUD() {
            const w = WEAPONS[PLAYER.wepIdx];
            document.getElementById('weapon-name').innerText = w.name;
            document.getElementById('ammo-cur').innerText = w.ammo;
            document.getElementById('bar-hp').style.width = PLAYER.hp+'%';
            document.getElementById('bar-sp').style.width = PLAYER.sp+'%';
            document.getElementById('molotov-count').innerText = 'x' + PLAYER.molotovCharges;
        }

        function swap(i) { if(!PLAYER.reloading) { PLAYER.wepIdx = i; updateHUD(); } }

        function togglePause() {
            if(!STATE.isRunning) return;
            STATE.paused = !STATE.paused;
            const screen = document.getElementById('pause-screen');
            const hud = document.getElementById('hud');
            
            if(STATE.paused) {
                playSound('ui_pause');
                screen.classList.remove('hidden'); screen.classList.add('flex');
                hud.classList.add('hidden');
                document.body.style.cursor = 'default';
            } else {
                playSound('ui_start');
                screen.classList.add('hidden'); screen.classList.remove('flex');
                hud.classList.remove('hidden');
                document.body.style.cursor = 'none';
            }
        }

        function startGame() {
            initAudio(); const bgm = document.getElementById('bgm');
            playSound('ui_start');
            if(STATE.musicOn) bgm.play().catch(e => console.log("Audio play blocked:", e));

            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('hud').classList.remove('hidden');
            STATE.isRunning = true; STATE.paused = false; STATE.level = 1; STATE.nextLevelTime = 30;
            spawnRate = 300; maxEnemies = 200; PLAYER.sp = 100;
            
            gsap.to(camera.position, {
                x: CAM_MODE.DEFAULT.x, 
                y: CAM_MODE.DEFAULT.y, 
                z: CAM_MODE.DEFAULT.z, 
                duration: 1.5
            });

            for(let i=0; i<15; i++) spawnEnemy();
            if(spawnInterval) clearInterval(spawnInterval); spawnInterval = setInterval(spawnEnemy, spawnRate);
        }
        
        function resetGame() {
            STATE.isRunning = false; STATE.paused = false;
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('pause-screen').classList.remove('flex');
            
            if(spawnInterval) clearInterval(spawnInterval);
            enemies.forEach(e => { scene.remove(e.mesh); world.removeBody(e.body); }); enemies = [];
            bullets.forEach(b => { scene.remove(b.mesh); }); bullets = [];
            enemyBullets.forEach(b => { scene.remove(b.mesh); }); enemyBullets = [];
            enemyProjectiles.forEach(p => { scene.remove(p.mesh); }); enemyProjectiles = [];
            particles.forEach(p => { scene.remove(p.mesh); if(p.indicator) scene.remove(p.indicator); }); particles = [];
            fireZones.forEach(z => scene.remove(z.mesh)); fireZones = [];
            loot.forEach(l => scene.remove(l.mesh)); loot = [];
            regenerateMap();
            world.removeBody(playerBody); scene.remove(playerMesh); createPlayer();
            
            PLAYER.hp = 100; PLAYER.sp = 100; PLAYER.molotovCharges = 2; PLAYER.wepIdx = 0; PLAYER.frozenTimer = 0;
            PLAYER.reloading = false; PLAYER.dashCd = false; PLAYER.leechAttached = false; PLAYER.leechSlowTimer = 0;
            document.getElementById('leech-warning').style.display = 'none';
            document.getElementById('slowed-label').style.display = 'none';
            attachedLeechMesh = null;

            WEAPONS.forEach(w => { w.ammo = w.max; w.lastShot = 0; });
            STATE.time = 0; document.getElementById('timer').innerText = "00:00";
            document.getElementById('level-display').innerText = "THREAT LEVEL: 1";
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('frost-overlay').classList.add('hidden');
            document.getElementById('reload-bar-bg').style.display = 'none';
            document.getElementById('ammo-cur').classList.remove('reloading-text');
            updateHUD(); startGame();
        }

        function gameOver() {
            playSound('ui_over');
            STATE.isRunning = false;
            document.getElementById('game-over').classList.remove('hidden');
            document.getElementById('game-over').classList.add('flex');
            document.getElementById('reload-bar-bg').style.display = 'none';
            document.getElementById('ammo-cur').classList.remove('reloading-text');
            
            let count = 0; const final = Math.floor(STATE.time); const el = document.getElementById('final-time');
            const counter = setInterval(() => {
                count += 1;
                const mm = Math.floor(count/60).toString().padStart(2,'0');
                const ss = Math.floor(count%60).toString().padStart(2,'0');
                el.innerText = `${mm}:${ss}`;
                if(count >= final) clearInterval(counter);
            }, 20);
            if(spawnInterval) clearInterval(spawnInterval);
        }

        function checkPassiveReload() {
            WEAPONS.forEach((w, idx) => {
                if (idx !== PLAYER.wepIdx && w.ammo < w.max) {
                    if (STATE.time > w.lastShot + 5.0) {
                        w.ammo = w.max;
                    }
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if(STATE.paused) {
                composer.render(); return;
            }

            if(!STATE.isRunning) {
                orbitAngle += 0.005; camera.position.x = Math.sin(orbitAngle) * 40; camera.position.z = Math.cos(orbitAngle) * 40; camera.lookAt(0,0,0);
                composer.render(); return;
            }

            // Cap Delta to avoid explosions, target 60FPS physics
            delta = Math.min(clock.getDelta(), 0.05); 
            STATE.time += delta;
            world.step(1/60, delta, 3);
            
            // FIREWORKS DECORATION
            if(STATE.time > STATE.lastFirework + 5.0) { // Changed to 5.0s
                STATE.lastFirework = STATE.time;
                if(Math.random() > 0.5) spawnFirework();
            }

            updatePlayer(); 
            handleShooting(); 
            checkPassiveReload();
            updateEntities(); 
            updateParticles(); 
            checkLoot(); 
            updateMeteors();
            
            const m = Math.floor(STATE.time/60).toString().padStart(2,'0');
            const s = Math.floor(STATE.time%60).toString().padStart(2,'0');
            document.getElementById('timer').innerText = `${m}:${s}`;
            
            if(STATE.mapGlitching) {
                STATE.glitchTimer -= delta;
                dynamicProps.forEach(p => {
                    if(Math.random() > 0.5) p.mesh.scale.multiplyScalar(1.0 + (Math.random()-0.5)*0.2); 
                    else p.mesh.scale.copy(p.originalScale);
                });
                if(STATE.glitchTimer <= 0) {
                    STATE.mapGlitching = false; dynamicProps.forEach(p => p.mesh.scale.copy(p.originalScale));
                }
            }

            if(STATE.time > STATE.nextLevelTime && STATE.level < 10) {
                STATE.level++; STATE.nextLevelTime += 30; regenerateMap();
                if(STATE.level === 3) { spawnRate = 300; maxEnemies = 200; showNotification("DOUBLE THREAT"); } 
                else if (STATE.level > 3) { spawnRate = Math.max(100, spawnRate - 50); maxEnemies += 50; showNotification("CHAOS RISING"); }
                clearInterval(spawnInterval); spawnInterval = setInterval(spawnEnemy, spawnRate);
                document.getElementById('level-display').innerText = "THREAT LEVEL: " + STATE.level;
            }
            composer.render();
        }

        init();
    </script>
</body>
</html>