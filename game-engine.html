<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyber-Soldier: THE ULTIMATE EDITION</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
            "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js"
        }
    }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Orbitron', sans-serif; user-select: none; cursor: none; }
        
        /* UPDATED: Canvas height 85vh, aligned to bottom to clear header space */
        #canvas-container { 
            width: 100vw; 
            height: 85vh; /* 85% Height */
            position: absolute; 
            bottom: 0; /* Align to bottom */
            left: 0; 
            z-index: 1; 
        }
        
        .ui-layer { position: absolute; z-index: 10; pointer-events: none; }
        .interactive { pointer-events: auto; cursor: default; }
        .frozen-overlay { box-shadow: inset 0 0 50px #00ffff; pointer-events: none; }

        /* CUSTOM MOUSE */
        #custom-cursor {
            position: absolute; width: 40px; height: 40px; border: 2px solid #ffffff; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 999;
            box-shadow: 0 0 15px #ffffff; transition: transform 0.05s; mix-blend-mode: difference;
        }
        #cursor-dot {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: red; 
            border-radius: 50%; transform: translate(-50%, -50%);
        }
        #reload-bar-bg {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            width: 40px; height: 6px; background: rgba(0,0,0,0.8);
            border: 1px solid #0088ff; border-radius: 4px;
            display: none; overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 136, 255, 0.3);
        }
        #reload-bar-fill { width: 0%; height: 100%; background: #0088ff; box-shadow: 0 0 10px #0088ff; }

        /* ANIMATIONS */
        @keyframes textGlitch {
            0% { text-shadow: 2px 2px #ff0000, -2px -2px #0000ff; transform: translate(0,0); }
            20% { text-shadow: -2px -2px #ff0000, 2px 2px #0000ff; transform: translate(-1px, 1px); }
            40% { text-shadow: 2px -2px #ff0000, -2px 2px #0000ff; transform: translate(1px, -1px); }
            60% { text-shadow: -2px 2px #ff0000, 2px -2px #0000ff; transform: translate(-1px, -1px); }
            80% { text-shadow: 2px 2px #ff0000, -2px -2px #0000ff; transform: translate(1px, 1px); }
            100% { text-shadow: -2px -2px #ff0000, 2px 2px #0000ff; transform: translate(0,0); }
        }
        .glitch-text { animation: textGlitch 0.5s infinite; }
        .fade-in-up { animation: fadeInUp 0.8s ease-out forwards; opacity: 0; transform: translateY(20px); }
        @keyframes fadeInUp { to { opacity: 1; transform: translateY(0); } }

        /* BUTTON STYLE */
        .btn-epic { 
            background: transparent; border: 2px solid cyan; color: cyan; box-shadow: 0 0 15px cyan; transition: all 0.3s;
        }
        .btn-epic:hover { background: cyan; color: black; box-shadow: 0 0 30px cyan; transform: scale(1.05); }

        /* LEECH WARNING - TAP ANIMATION */
        #leech-warning {
            position: absolute; top: 65%; left: 50%; transform: translate(-50%, -50%);
            color: #ccff00; font-weight: 900; font-size: 28px; letter-spacing: 2px;
            display: none; text-shadow: 0 0 15px #ccff00;
            animation: tapPanic 0.15s infinite alternate; pointer-events: none;
        }
        @keyframes tapPanic { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.2); } }
        
        #slowed-label {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            color: #ff4444; font-weight: 900; font-size: 16px; letter-spacing: 2px;
            display: none; text-shadow: 0 0 10px #ff0000; pointer-events: none;
        }

        /* CONTROL TIPS */
        .key-bubble {
            width: 30px; height: 30px; border: 2px solid white; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 12px; box-shadow: 0 0 5px white;
            color: white; background: rgba(0,0,0,0.5); transition: all 0.1s ease-out;
        }
        .tip-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 12px; color: #ccc; }
        .key-active { background-color: white !important; color: black !important; box-shadow: 0 0 15px white !important; transform: scale(1.15); border-color: white !important; }

        /* AMMO RELOAD ANIM */
        @keyframes ammoFlip {
            0% { transform: rotateX(0deg); color: white; opacity: 1; }
            50% { transform: rotateX(90deg); color: red; opacity: 0.5; }
            100% { transform: rotateX(0deg); color: white; opacity: 1; }
        }
        .reloading-text { animation: ammoFlip 0.8s infinite linear; }

        /* NOTIFICATIONS - REFINED */
        #notification-zone {
            position: absolute; top: 20px; right: 20px; width: 250px; /* Smaller */
            display: flex; flex-direction: column; align-items: flex-end; gap: 5px;
            pointer-events: none;
        }
        .notif-card {
            background: rgba(0, 0, 0, 0.5); /* More transparent */
            border-right: 3px solid cyan;
            padding: 8px 15px; color: rgba(255,255,255,0.9); font-weight: bold; font-family: monospace; font-size: 14px;
            text-shadow: 0 0 5px cyan; transform: translateX(100%);
            animation: slideInRight 0.3s forwards, slideOutRight 0.3s 1.7s forwards; /* Faster removal (2s total) */
        }
        @keyframes slideInRight { to { transform: translateX(0); } }
        @keyframes slideOutRight { to { transform: translateX(120%); } }

        /* CREDITS */
        .credits {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            font-size: 10px; color: rgba(255,255,255,0.7); letter-spacing: 3px;
            text-shadow: 0 0 5px white; animation: pulseText 3s infinite;
        }
        @keyframes pulseText { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }

        /* HUD POSITIONING ADJUSTMENT for 85vh */
        #hud { height: 85vh; bottom: 0; top: auto; }
        #start-screen { height: 85vh; bottom: 0; top: auto; }
        #game-over { height: 85vh; bottom: 0; top: auto; }
        #frost-overlay { height: 85vh; bottom: 0; top: auto; }
    </style>
</head>
<body>

    <!-- Background Music -->
    <audio id="bgm" src="public/11-musicgame/musicbackground.mp4" loop></audio>

    <div id="canvas-container"></div>
    <div id="frost-overlay" class="absolute hidden pointer-events-none z-20" style="width: 100vw; background: radial-gradient(circle, transparent 60%, rgba(0, 255, 255, 0.3) 100%);"></div>
    <div class="scanline"></div>

    <div id="custom-cursor">
        <div id="cursor-dot"></div>
        <div id="reload-bar-bg"><div id="reload-bar-fill"></div></div>
    </div>
    
    <div id="leech-warning">PRESS [F] TO DETACH!</div>
    <div id="slowed-label">SLOWED</div>

    <div id="start-screen" class="ui-layer interactive w-full flex flex-col items-center justify-center bg-black/60 z-50 backdrop-blur-sm">
        <h1 class="text-8xl font-black text-white mb-8 tracking-tighter fade-in-up glitch-text" style="text-shadow: 0 0 30px cyan;">NEON CHAOS</h1>
        <div class="flex gap-8 items-center fade-in-up" style="animation-delay: 0.2s;">
            <button id="btn-start" class="px-20 py-6 text-2xl font-bold uppercase tracking-widest btn-epic">
                INITIATE
            </button>
        </div>
    </div>

    <div id="notification-zone" class="ui-layer"></div>

    <div id="hud" class="ui-layer w-full hidden">
        <div class="absolute top-6 left-6 w-80 font-mono">
            <div class="flex justify-between text-xs text-white mb-1 font-bold"><span>HP STATUS</span></div>
            <div class="w-full h-5 bg-black/60 border border-white transform -skew-x-12 overflow-hidden shadow-[0_0_10px_#ffffff]">
                <div id="bar-hp" class="h-full w-full transition-all duration-200" style="background: linear-gradient(90deg, #555, #fff);"></div>
            </div>
            <div class="flex justify-between text-xs text-gray-300 mt-2 mb-1 font-bold"><span>STAMINA</span></div>
            <div class="w-full h-2 bg-black/60 border border-gray-500 transform -skew-x-12">
                <div id="bar-sp" class="h-full bg-gray-400 w-full transition-all duration-200"></div>
            </div>
            <div class="flex justify-between text-xs text-orange-400 mt-4 mb-1 font-bold">
                <span>MOLOTOV [E]</span><span id="molotov-count" class="text-white">x2</span>
            </div>
            <div class="w-32 h-1 bg-black/60 border border-orange-600">
                <div id="bar-molotov" class="h-full bg-orange-500 w-full transition-all duration-100"></div>
            </div>
            <div id="q-indicator" class="mt-4 text-xs font-bold text-white border border-white p-2 inline-block">AUTO-FIRE [Q]: <span id="q-status">ON</span></div>
        </div>

        <div class="absolute top-6 left-1/2 -translate-x-1/2 text-center w-full pointer-events-none">
            <div id="timer" class="text-5xl font-black text-white tracking-widest drop-shadow-[0_0_10px_white]">00:00</div>
            <div id="level-display" class="text-sm font-bold text-cyan-400 tracking-widest mt-1">THREAT LEVEL: 1</div>
        </div>

        <div class="absolute bottom-6 right-6 text-right font-mono">
            <div id="weapon-name" class="text-6xl font-black text-white italic uppercase tracking-tighter" style="text-shadow: 0 0 15px white;">SMG</div>
            <div class="flex justify-end items-end gap-2 mt-2" id="ammo-container">
                <div class="text-6xl font-bold text-white leading-none" id="ammo-cur">50</div>
                <div class="text-2xl text-gray-500 mb-1">/ <span id="ammo-max">âˆž</span></div>
            </div>
        </div>

        <div class="absolute bottom-6 left-6 font-mono pointer-events-none transition-all">
            <div class="tip-row"><div id="key-w" class="key-bubble">W</div><div id="key-a" class="key-bubble">A</div><div id="key-s" class="key-bubble">S</div><div id="key-d" class="key-bubble">D</div> <span>MOVE</span></div>
            <div class="tip-row"><div id="key-spc" class="key-bubble">SPC</div> <span>DASH (10 SP)</span></div>
            <div class="tip-row"><div id="key-f" class="key-bubble">F</div> <span>MELEE (8 SP)</span></div>
            <div class="tip-row"><div id="key-e" class="key-bubble">E</div> <span>MOLOTOV</span></div>
            <div class="tip-row"><div id="key-q" class="key-bubble">Q</div> <span>AUTO-AIM</span></div>
            <div class="tip-row"><div id="key-1" class="key-bubble">1</div><div id="key-2" class="key-bubble">2</div><div id="key-3" class="key-bubble">3</div> <span>WEAPON</span></div>
        </div>

        <div id="damage-overlay" class="absolute inset-0 bg-red-600 mix-blend-overlay opacity-0 pointer-events-none transition-opacity duration-100"></div>
        <div class="credits">DESIGN & DEVELOP GAME BY NANDO</div>
    </div>

    <div id="game-over" class="ui-layer interactive w-full hidden flex-col items-center justify-center bg-red-900/20 backdrop-blur-md z-50">
        <div class="glitch-text text-7xl font-black text-white mb-4 tracking-tighter drop-shadow-lg">SYSTEM FAILURE</div>
        <div class="text-3xl text-white font-mono mb-8 fade-in-up">SURVIVED: <span id="final-time" class="font-bold text-yellow-300">00:00</span></div>
        <button id="btn-restart" class="px-16 py-4 bg-white text-black font-bold hover:bg-gray-200 transition uppercase tracking-widest cursor-pointer shadow-2xl fade-in-up" style="animation-delay: 0.2s;">REBOOT SYSTEM</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

        // --- CONFIG ---
        const CONFIG = {
            ARENA_SIZE: 75,
            SPEED_BASE: 14,
            SPEED_DASH: 35,
            COLORS: {
                PLAYER: 0xffffff,
                SCOUT: 0x00ffaa,
                RUSHER: 0xffaa00,
                HEAVY: 0xff003c,
                SHOOTER: 0xaa00ff,
                TYRANT: 0x000000,
                ELITE: 0xff00ff, 
                PYRO: 0xd90036,
                LEECH: 0xccff00, 
                BG: 0x050505,
                GRID: 0x444444,
                NEON_CYAN: 0x00ffff
            }
        };

        const STATE = {
            isRunning: false,
            time: 0,
            lastMeteor: 0,
            hellRain: false,
            autoFireActive: true, 
            level: 1,
            nextLevelTime: 30,
            mapGlitching: false,
            glitchTimer: 0
        };

        const PLAYER = {
            hp: 100, maxHp: 100,
            sp: 100, maxSp: 100,
            wepIdx: 0,
            reloading: false,
            dashCd: false,
            molotovCharges: 2,
            molotovMaxCharges: 2,
            molotovRecharge: 0, 
            molotovRechargeTime: 3, 
            frozenTimer: 0,
            leechAttached: false,
            leechSlowTimer: 0,
            isDashing: false,
            dashTimer: 0
        };

        const WEAPONS = [
            { name: 'SMG', dmg: 8, ammo: 50, max: 50, rate: 0.05, spread: 0.08 },
            { name: 'SHOTGUN', dmg: 18, ammo: 6, max: 6, rate: 0.8, spread: 0.5, pellets: 8 },
            { name: 'SNIPER', dmg: 120, ammo: 4, max: 4, rate: 0.8, spread: 0.001, pellets: 1 }
        ];

        // --- GLOBAL ---
        let scene, camera, renderer, composer, glitchPass, world, physMat;
        let playerMesh, playerBody;
        let clock, delta;
        let spawnInterval;
        let spawnRate = 300; 
        let maxEnemies = 200; 
        
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let enemyProjectiles = []; 
        let particles = [];
        let loot = [];
        let props = []; 
        let dynamicProps = []; // Stores {body, mesh, originalScale, box: THREE.Box3}
        let fireZones = [];
        let attachedLeechMesh = null;
        
        // POOLING
        const geoms = {};
        const mats = {};
        
        const gradients = {};
        let hpBarTexture;
        let buildingTexture;

        const keys = { w:0, a:0, s:0, d:0, click:0 };
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const groundPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
        let orbitAngle = 0;

        // --- SOUND SYSTEM ---
        let audioCtx;
        function initAudio() {
            if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playGunSound(type) {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if(type === 'SMG') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
            } else if(type === 'SHOTGUN') {
                // Noise burst
                const bufferSize = audioCtx.sampleRate * 0.3; // 300ms
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
                
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                
                // Filter for "thud" sound
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                
                noise.connect(filter);
                filter.connect(gain);
                
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                
                noise.start(t);
            } else if(type === 'SNIPER') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.5);
                
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                
                osc.start(t);
                osc.stop(t + 0.5);
                
                // Add an echo effect if possible (simplified here)
                // Just a second quieter beep
                const osc2 = audioCtx.createOscillator();
                const gain2 = audioCtx.createGain();
                osc2.connect(gain2);
                gain2.connect(audioCtx.destination);
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(150, t+0.1);
                osc2.frequency.linearRampToValueAtTime(0, t+0.4);
                gain2.gain.setValueAtTime(0.1, t+0.1);
                gain2.gain.linearRampToValueAtTime(0, t+0.4);
                osc2.start(t+0.1);
                osc2.stop(t+0.4);
            }
        }

        function playImpactSound(type) {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            if(type === 'snow') {
                // High pitched shatter
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(2000, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.3);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);
            } else {
                // Low boom
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
            }
            osc.start(t);
            osc.stop(t + 0.5);
        }

        function createGradientTexture(colorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createLinearGradient(0, 0, 0, 64);
            const col = new THREE.Color(colorHex);
            grd.addColorStop(0, col.clone().offsetHSL(0, 0, 0.2).getStyle());
            grd.addColorStop(1, col.clone().offsetHSL(0, 0, -0.1).getStyle());
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = "rgba(0,0,0,0.2)";
            for(let i=0; i<64; i+=4) ctx.fillRect(0, i, 64, 1);
            return new THREE.CanvasTexture(canvas);
        }

        function createHpBarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 16;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createLinearGradient(0, 0, 128, 0);
            grd.addColorStop(0, '#ff0000');
            grd.addColorStop(0.5, '#ffff00');
            grd.addColorStop(1, '#00ff00');
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 16);
            return new THREE.CanvasTexture(canvas);
        }

        function createBuildingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#aaaaaa'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#666666'; 
            for(let y=8; y<128; y+=16) { for(let x=8; x<128; x+=16) { ctx.fillRect(x,y, 8, 8); } }
            ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 4; ctx.strokeRect(0,0,128,128);
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        function init() {
            try {
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(CONFIG.COLORS.BG, 0.015);
                scene.background = new THREE.Color(CONFIG.COLORS.BG);

                camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.set(0, 60, 40); 
                camera.lookAt(0,0,0);

                renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                // UPDATE: Use 85% height
                renderer.setSize(window.innerWidth, window.innerHeight * 0.85);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                const renderPass = new RenderPass(scene, camera);
                // UPDATE: Resolution
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight * 0.85), 1.5, 0.4, 0.85);
                bloom.threshold = 0.1; bloom.strength = 1.8; bloom.radius = 0.5;
                
                glitchPass = new GlitchPass();
                glitchPass.enabled = false; 
                glitchPass.goWild = true;

                composer = new EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloom);
                composer.addPass(glitchPass);

                world = new CANNON.World();
                world.gravity.set(0, -60, 0);
                physMat = new CANNON.Material('slippery');
                world.addContactMaterial(new CANNON.ContactMaterial(physMat, physMat, { friction: 0.0, restitution: 0.0 }));

                const amb = new THREE.AmbientLight(0xffffff, 2.5);
                scene.add(amb);
                const sun = new THREE.DirectionalLight(0xffffff, 2.0);
                sun.position.set(20, 60, 20);
                sun.castShadow = true;
                scene.add(sun);

                // --- POOLING INIT ---
                geoms.bulletSMG = new THREE.CapsuleGeometry(0.08, 0.8, 4, 8);
                geoms.bulletSMG.rotateX(-Math.PI/2);
                geoms.bulletShotgun = new THREE.SphereGeometry(0.2, 8, 8);
                geoms.bulletSniper = new THREE.CapsuleGeometry(0.15, 8.0, 4, 8);
                geoms.bulletSniper.rotateX(-Math.PI/2);
                geoms.enemyBullet = new THREE.BoxGeometry(0.2, 0.2, 1.0);
                
                mats.neonCyan = new THREE.MeshBasicMaterial({ color: CONFIG.COLORS.NEON_CYAN });
                mats.enemyBullet = new THREE.MeshBasicMaterial({ color: CONFIG.COLORS.SHOOTER });

                // Textures
                gradients['player'] = createGradientTexture(CONFIG.COLORS.NEON_CYAN);
                gradients['scout'] = createGradientTexture(CONFIG.COLORS.SCOUT);
                gradients['rusher'] = createGradientTexture(CONFIG.COLORS.RUSHER);
                gradients['heavy'] = createGradientTexture(CONFIG.COLORS.HEAVY);
                gradients['shooter'] = createGradientTexture(CONFIG.COLORS.SHOOTER);
                gradients['tyrant'] = createGradientTexture(0x444444);
                gradients['elite'] = createGradientTexture(CONFIG.COLORS.ELITE);
                gradients['pyro'] = createGradientTexture(CONFIG.COLORS.PYRO);
                gradients['leech'] = createGradientTexture(CONFIG.COLORS.LEECH);
                hpBarTexture = createHpBarTexture();
                buildingTexture = createBuildingTexture();

                createLevel();
                createPlayer();
                initInput();
                updateAutoFireUI();

                document.getElementById('btn-start').addEventListener('click', startGame);
                document.getElementById('btn-restart').addEventListener('click', resetGame);
                window.addEventListener('resize', onResize);

                clock = new THREE.Clock();
                
                // --- LOADING REMOVED, DIRECT RENDER ---
                const start = document.getElementById('start-screen');
                const canvasCont = document.getElementById('canvas-container');
                start.style.display = 'flex';
                canvasCont.style.opacity = 1; 
                composer.render();
                
                animate();

            } catch (e) { console.error(e); }
        }

        function onResize() {
            // UPDATE: Resize logic for 85% height
            const h = window.innerHeight * 0.85;
            camera.aspect = window.innerWidth / h;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, h);
            composer.setSize(window.innerWidth, h);
        }

        function highlightKey(key, active) {
            let id = '';
            if(key === 'w') id = 'key-w';
            else if(key === 'a') id = 'key-a';
            else if(key === 's') id = 'key-s';
            else if(key === 'd') id = 'key-d';
            else if(key === ' ') id = 'key-spc';
            else if(key === 'f') id = 'key-f';
            else if(key === 'e') id = 'key-e';
            else if(key === 'q') id = 'key-q';
            else if(key === '1') id = 'key-1';
            else if(key === '2') id = 'key-2';
            else if(key === '3') id = 'key-3';

            if(id) {
                const el = document.getElementById(id);
                if(active) el.classList.add('key-active');
                else el.classList.remove('key-active');
            }
        }

        function initInput() {
            window.addEventListener('keydown', e => {
                const k = e.key.toLowerCase();
                highlightKey(k, true); 
                if(k==='w') keys.w=1; if(k==='a') keys.a=1; if(k==='s') keys.s=1; if(k==='d') keys.d=1;
                if(k===' ') handleDash();
                if(k==='r') handleReload();
                if(k==='f') handleMelee();
                if(k==='e') handleMolotov();
                if(k==='q') toggleAutoFire();
                if(k==='1') swap(0); if(k==='2') swap(1); if(k==='3') swap(2);
            });
            window.addEventListener('keyup', e => {
                const k = e.key.toLowerCase();
                highlightKey(k, false); 
                if(k==='w') keys.w=0; if(k==='a') keys.a=0; if(k==='s') keys.s=0; if(k==='d') keys.d=0;
            });
            window.addEventListener('mousedown', () => keys.click=1);
            window.addEventListener('mouseup', () => keys.click=0);
            window.addEventListener('mousemove', e => {
                // UPDATE: Mouse coordinates relative to canvas (not window)
                const canvas = renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                const cur = document.getElementById('custom-cursor');
                if(cur) { cur.style.left = e.clientX+'px'; cur.style.top = e.clientY+'px'; }
            });
        }

        function toggleAutoFire() {
            STATE.autoFireActive = !STATE.autoFireActive;
            updateAutoFireUI();
        }

        function updateAutoFireUI() {
            const el = document.getElementById('q-indicator');
            const st = document.getElementById('q-status');
            if(STATE.autoFireActive) {
                st.innerText = "ON";
                document.getElementById('key-q').classList.add('key-active'); 
            } else {
                st.innerText = "OFF";
                document.getElementById('key-q').classList.remove('key-active');
            }
        }

        function showNotification(text) {
            const zone = document.getElementById('notification-zone');
            const card = document.createElement('div');
            card.className = 'notif-card';
            card.innerText = text;
            zone.appendChild(card);
            setTimeout(() => card.remove(), 2000); 
        }

        function createLevel() {
            const geo = new THREE.PlaneGeometry(160, 160);
            const mat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2; mesh.receiveShadow = true;
            scene.add(mesh);

            // PULSING GRID
            const grid = new THREE.GridHelper(150, 75, 0xffffff, 0x444444);
            grid.position.y = 0.05; scene.add(grid);
            STATE.grid = grid; // Store ref

            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: physMat });
            body.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            world.addBody(body);

            // STATIC WALLS - ADD BBOX
            const wShape = new CANNON.Box(new CANNON.Vec3(75, 10, 1));
            const walls = [[0,5,-75],[0,5,75],[-75,5,0,Math.PI/2],[75,5,0,Math.PI/2]];
            walls.forEach(p => {
                const b = new CANNON.Body({ mass:0, position:new CANNON.Vec3(p[0],p[1],p[2]) });
                b.addShape(wShape);
                if(p[3]) b.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), p[3]);
                world.addBody(b);
            });

            regenerateMap();
        }

        function regenerateMap() {
            STATE.mapGlitching = true;
            STATE.glitchTimer = 1.0;

            dynamicProps.forEach(p => { scene.remove(p.mesh); world.removeBody(p.body); });
            dynamicProps = [];

            if(STATE.isRunning) showNotification("MAP RECONFIGURING");

            for(let i=0; i<50; i++) {
                const x = (Math.random()-0.5)*130;
                const z = (Math.random()-0.5)*130;
                
                if(Math.abs(x)<15 && Math.abs(z)<15) continue;
                if(playerMesh && new THREE.Vector3(x,0,z).distanceTo(playerMesh.position) < 10) continue;

                const w = Math.random()*6+4;
                const h = Math.random()*8+4;
                
                const b = new CANNON.Body({ mass:0, position:new CANNON.Vec3(x,h/2,z), material:physMat });
                b.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,w/2))); 
                world.addBody(b);
                
                const geo = new THREE.BoxGeometry(w, h, w);
                const mat = new THREE.MeshStandardMaterial({
                    map: buildingTexture, 
                    emissive: 0xaaaaaa, 
                    emissiveMap: buildingTexture,
                    emissiveIntensity: 2.0,
                    color: 0x888888 
                });
                
                const m = new THREE.Mesh(geo, mat);
                m.position.set(x, h/2, z);
                m.castShadow = true; m.receiveShadow = true;
                
                // BOX3 FOR COLLISION
                const box = new THREE.Box3().setFromObject(m);

                gsap.to(m.material, { emissiveIntensity: 0.1, duration: 1.0, ease: "power2.out" });

                scene.add(m);
                dynamicProps.push({body:b, mesh:m, originalScale: m.scale.clone(), box: box});
            }
        }

        function createPlayer() {
            playerBody = new CANNON.Body({ mass: 60, position: new CANNON.Vec3(0, 2, 0), shape: new CANNON.Sphere(1), material: physMat, fixedRotation: true, linearDamping: 0.9 });
            world.addBody(playerBody);

            playerMesh = new THREE.Group();
            
            // ROBOT MATERIALS - LIGHTER ARMOR
            const armorMat = new THREE.MeshStandardMaterial({ 
                color: 0x88aaff, // Lighter Blue-Grey
                metalness: 0.9, roughness: 0.1 
            });
            const jointMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const neonMat = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 8.0 
            }); // MAX INTENSITY

            // SCALE PLAYER UP
            playerMesh.scale.setScalar(1.3);

            // --- FLOOR HIGHLIGHT ---
            const ringGeo = new THREE.RingGeometry(1.2, 1.5, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.1;
            playerMesh.add(ring);

            // --- HIPS ---
            const hips = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.4, 0.5), armorMat);
            hips.position.y = 0.8;
            playerMesh.add(hips);

            // --- LEGS (WALKING) ---
            const legGeo = new THREE.BoxGeometry(0.35, 0.8, 0.4);
            
            const legL = new THREE.Group();
            legL.position.set(-0.25, 0, 0); // Relative to hips
            const legLMesh = new THREE.Mesh(legGeo, armorMat);
            legLMesh.position.y = -0.4;
            legL.add(legLMesh);
            hips.add(legL);

            const legR = new THREE.Group();
            legR.position.set(0.25, 0, 0); // Relative to hips
            const legRMesh = new THREE.Mesh(legGeo, armorMat);
            legRMesh.position.y = -0.4;
            legR.add(legRMesh);
            hips.add(legR);

            // --- TORSO ---
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.8, 0.7), armorMat);
            torso.position.y = 1.5;
            torso.castShadow = true;
            playerMesh.add(torso);

            // Core Reactor (Chest) - High Viz
            const core = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8), neonMat);
            core.rotation.x = Math.PI/2;
            core.position.set(0, 1.5, 0.36); 
            playerMesh.add(core);

            // --- HEAD ---
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.6), armorMat);
            head.position.y = 2.2;
            playerMesh.add(head);

            // Visor - High Viz
            const visor = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.15, 0.1), neonMat);
            visor.position.set(0, 0, 0.31); 
            head.add(visor);

            // --- ARMS ---
            // Shoulders
            const shoulderGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const shoulderL = new THREE.Mesh(shoulderGeo, armorMat);
            shoulderL.position.set(-0.7, 1.7, 0);
            playerMesh.add(shoulderL);

            const shoulderR = new THREE.Mesh(shoulderGeo, armorMat);
            shoulderR.position.set(0.7, 1.7, 0);
            playerMesh.add(shoulderR);

            // Right Arm (Weapon Holder)
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), jointMat);
            armR.position.set(0, -0.4, 0);
            shoulderR.add(armR);

            // WEAPON (Railgun Style)
            const gunGrp = new THREE.Group();
            gunGrp.position.set(0, -0.3, 0.3); // Hold position
            armR.add(gunGrp);

            const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 1.5), new THREE.MeshStandardMaterial({color: 0x444444}));
            gunBody.position.set(0, 0, 0.4);
            gunGrp.add(gunBody);

            const gunBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1.6), neonMat);
            gunBarrel.position.set(0, 0.1, 0.5);
            gunGrp.add(gunBarrel);

            // --- SHOOTING TIP ---
            const gunTip = new THREE.Object3D();
            gunTip.position.set(0, 0, 0.8); // Tip of barrel
            gunBarrel.add(gunTip);

            // Left Arm
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), jointMat);
            armL.position.set(0, -0.4, 0);
            shoulderL.add(armL);
            
            // Left Hand (Fist)
            const fistL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), armorMat);
            fistL.position.set(0, -0.4, 0);
            armL.add(fistL);

            // LIGHT - Follow player
            const pl = new THREE.PointLight(0x00ffff, 4, 30); // Increased intensity
            pl.position.set(0, 3, 0);
            playerMesh.add(pl);

            // Store references
            playerMesh.userData = { visor, neonMat, gunTip, torso, core, legL, legR };

            scene.add(playerMesh);
        }

        function updatePlayer() {
            if(!STATE.isRunning || PLAYER.hp <= 0) return;

            if(PLAYER.frozenTimer > 0) {
                PLAYER.frozenTimer -= delta;
                document.getElementById('frost-overlay').classList.remove('hidden');
                if(playerMesh.userData.neonMat) playerMesh.userData.neonMat.color.setHex(0xffffff);
                return; 
            } else {
                document.getElementById('frost-overlay').classList.add('hidden');
                if(playerMesh.userData.neonMat) playerMesh.userData.neonMat.color.setHex(0x00ffff);
            }

            // LEECH CHECK
            let speedMod = 1.0;
            if(PLAYER.leechSlowTimer > 0) {
                PLAYER.leechSlowTimer -= delta;
                speedMod = 0.7; 
                document.getElementById('slowed-label').style.display = 'block';
            } else {
                document.getElementById('slowed-label').style.display = 'none';
            }

            const input = new THREE.Vector3(keys.d-keys.a, 0, keys.s-keys.w).normalize();
            let spd = PLAYER.dashCd ? CONFIG.SPEED_DASH : CONFIG.SPEED_BASE;
            spd *= speedMod;
            
            playerBody.velocity.x = input.x * spd;
            playerBody.velocity.z = input.z * spd;

            // ANIMATION: WALKING LEGS
            if(input.lengthSq() > 0.1) {
                const walkSpeed = 15;
                playerMesh.userData.legL.rotation.x = Math.sin(STATE.time * walkSpeed) * 0.5;
                playerMesh.userData.legR.rotation.x = Math.sin(STATE.time * walkSpeed + Math.PI) * 0.5;
            } else {
                playerMesh.userData.legL.rotation.x = 0;
                playerMesh.userData.legR.rotation.x = 0;
            }

            // ANIMATION: TILT (Lean into movement)
            const tiltX = playerBody.velocity.z * 0.005;
            const tiltZ = -playerBody.velocity.x * 0.005;
            gsap.to(playerMesh.rotation, { x: tiltX, z: tiltZ, duration: 0.2 });

            // CAMERA NO SHAKE
            const targetPos = new THREE.Vector3(
                playerMesh.position.x,
                50, 
                playerMesh.position.z + 35
            );
            
            camera.position.lerp(targetPos, 0.1); 
            camera.lookAt(playerMesh.position); 

            playerMesh.position.copy(playerBody.position);
            playerMesh.position.y -= 1;
            
            raycaster.setFromCamera(mouse, camera);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, target);
            playerMesh.lookAt(target.x, playerMesh.position.y, target.z);

            if(PLAYER.sp < PLAYER.maxSp && !PLAYER.dashCd) PLAYER.sp += 15 * delta;
            
            if(PLAYER.molotovCharges < PLAYER.molotovMaxCharges) {
                PLAYER.molotovRecharge += delta;
                if(PLAYER.molotovRecharge >= PLAYER.molotovRechargeTime) {
                    PLAYER.molotovCharges++;
                    PLAYER.molotovRecharge = 0;
                    updateHUD();
                }
                const pct = (PLAYER.molotovRecharge / PLAYER.molotovRechargeTime) * 100;
                document.getElementById('bar-molotov').style.width = pct + '%';
            } else {
                document.getElementById('bar-molotov').style.width = '100%';
            }

            // DASH TRAIL LOGIC
            if(PLAYER.isDashing) {
                PLAYER.dashTimer -= delta;
                if(PLAYER.dashTimer % 0.05 < delta) { // Spawn ghost every 0.05s
                    const ghost = playerMesh.clone();
                    ghost.position.copy(playerMesh.position);
                    ghost.rotation.copy(playerMesh.rotation);
                    ghost.scale.copy(playerMesh.scale);
                    
                    ghost.traverse(c => {
                        if(c.isMesh) {
                            c.material = new THREE.MeshBasicMaterial({color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.3});
                        }
                    });
                    scene.add(ghost);
                    gsap.to(ghost.material, {opacity: 0, duration: 0.3, onComplete: () => scene.remove(ghost)});
                }
            }
        }

        function handleDash() {
            if(PLAYER.dashCd || PLAYER.sp < 10 || PLAYER.frozenTimer > 0) return;
            PLAYER.dashCd = true;
            PLAYER.sp -= 10;
            PLAYER.isDashing = true;
            PLAYER.dashTimer = 0.2; // Dash Duration
            
            setTimeout(() => { 
                PLAYER.dashCd = false; 
                PLAYER.isDashing = false; 
            }, 200);
        }

        function handleShooting() {
            if(!STATE.isRunning || PLAYER.frozenTimer > 0) return;
            const w = WEAPONS[PLAYER.wepIdx];
            
            const trigger = keys.click || STATE.autoFireActive;
            
            if(trigger && !PLAYER.reloading && STATE.time > (w.lastShot || 0) + w.rate) {
                if(w.ammo > 0) {
                    w.ammo--;
                    w.lastShot = STATE.time;
                    
                    playGunSound(w.name); // PLAY SOUND

                    raycaster.setFromCamera(mouse, camera);
                    const target = new THREE.Vector3();
                    raycaster.ray.intersectPlane(groundPlane, target);
                    
                    const origin = new THREE.Vector3();
                    playerMesh.userData.gunTip.getWorldPosition(origin);

                    const dir = new THREE.Vector3().subVectors(target, origin).normalize();
                    dir.y = 0;

                    const cnt = w.pellets || 1;
                    
                    for(let i=0; i<cnt; i++) {
                        const spread = (Math.random()-0.5) * w.spread;
                        const finalDir = dir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), spread);
                        spawnBullet(origin, finalDir, w.dmg, true, PLAYER.wepIdx);
                    }

                    const ammoDiv = document.getElementById('ammo-cur');
                    ammoDiv.classList.remove('shake-effect');
                    void ammoDiv.offsetWidth; 
                    ammoDiv.classList.add('shake-effect');

                    updateHUD();
                } else {
                    handleReload();
                }
            }
        }

        function spawnBullet(pos, dir, dmg, isPlayer, wepIdx) {
            const isSniper = (isPlayer && wepIdx === 2);
            let mesh;
            let spd = 0;

            if (isPlayer) {
                // COLOR: Neon Cyan 
                const col = CONFIG.COLORS.NEON_CYAN;
                const neonMat = mats.neonCyan; // REUSE MATERIAL

                if (wepIdx === 0) { // SMG - Small Capsule
                    mesh = new THREE.Mesh(geoms.bulletSMG, neonMat); // REUSE GEO
                    spd = 90;
                } else if (wepIdx === 1) { // SHOTGUN - Small Sphere
                    mesh = new THREE.Mesh(geoms.bulletShotgun, neonMat); // REUSE GEO
                    spd = 70;
                } else { // SNIPER - Long Beam
                    mesh = new THREE.Mesh(geoms.bulletSniper, neonMat); // REUSE GEO
                    spd = 200;
                }
            } else {
                const geo = geoms.enemyBullet; // REUSE GEO
                const mat = mats.enemyBullet; // REUSE MAT
                mesh = new THREE.Mesh(geo, mat);
                spd = 35;
            }
            
            mesh.position.copy(pos);
            mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), dir);
            scene.add(mesh);
            
            const arr = isPlayer ? bullets : enemyBullets;
            
            arr.push({ 
                mesh:mesh, vel:dir.multiplyScalar(spd), dmg, life:2.0, piercing: isSniper, hitIds: [] 
            });
        }

        function handleMelee() {
            if(PLAYER.sp < 8 || PLAYER.frozenTimer > 0) return;
            PLAYER.sp -= 8;

            if(PLAYER.leechAttached) {
                PLAYER.leechAttached = false;
                if(attachedLeechMesh) {
                    scene.remove(attachedLeechMesh);
                    attachedLeechMesh = null;
                }
                document.getElementById('leech-warning').style.display = 'none';
                // spawnExplosion(playerMesh.position, CONFIG.COLORS.LEECH, 8); // REMOVED
            }

            // --- ANIMATION: SPIN ---
            gsap.to(playerMesh.rotation, {y: playerMesh.rotation.y + Math.PI*2, duration: 0.2});

            // --- VISUAL: LOADING SLASH 360 ---
            const waveGeo = new THREE.RingGeometry(5, 6, 64);
            const waveMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff, side: THREE.DoubleSide, opacity: 1.0, transparent: true, depthTest: false
            });
            const wave = new THREE.Mesh(waveGeo, waveMat);
            wave.rotation.x = -Math.PI/2;
            wave.position.copy(playerMesh.position);
            wave.position.y = 1.0;
            
            scene.add(wave);
            
            // "Loading" visual: Scale up from 0
            wave.scale.set(0, 0, 0);
            gsap.to(wave.scale, {x: 1.5, y: 1.5, duration: 0.2});
            gsap.to(wave.material, {opacity: 0, duration: 0.2, onComplete: () => scene.remove(wave)});

            // Hit Logic - 360
            const range = 9;
            enemies.forEach(e => {
                const dist = playerMesh.position.distanceTo(e.mesh.position);
                if(dist < range) {
                    e.hp -= 60;
                    const knockDir = new CANNON.Vec3().copy(e.body.position).vsub(playerBody.position);
                    knockDir.normalize();
                    e.body.velocity.set(knockDir.x*60, 5, knockDir.z*60); 
                    if(e.hp<=0) killEnemy(e);
                }
            });
        }

        function handleMolotov() {
            if(PLAYER.molotovCharges <= 0 || PLAYER.frozenTimer > 0) return;
            PLAYER.molotovCharges--;
            updateHUD();

            raycaster.setFromCamera(mouse, camera);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, target);

            const zone = new THREE.Mesh(new THREE.CircleGeometry(8, 32), new THREE.MeshBasicMaterial({color:0xff4400, side:THREE.DoubleSide, transparent:true, opacity:0.6}));
            zone.rotation.x = -Math.PI/2; zone.position.copy(target); zone.position.y = 0.1;
            scene.add(zone);
            
            fireZones.push({ mesh:zone, pos:target, life:5.0 });
        }

        function spawnEnemy() {
            if(!STATE.isRunning || enemies.length > maxEnemies) return; 

            let x, z;
            let valid = false;
            let attempts = 0;
            const minSpawnDist = 30; 
            
            while(!valid && attempts < 15) {
                x = (Math.random() - 0.5) * 120;
                z = (Math.random() - 0.5) * 120;
                const dist = new THREE.Vector3(x,0,z).distanceTo(playerMesh.position);
                if(dist > minSpawnDist) valid = true;
                attempts++;
            }
            if(!valid) return;

            const rnd = Math.random();
            let type = 'rusher';
            if(rnd > 0.98) type = 'leech'; 
            else if(rnd > 0.96) type = 'elite'; 
            else if(rnd > 0.94) type = 'pyro'; 
            else if(rnd > 0.90) type = 'tyrant';
            else if(rnd > 0.85) type = 'heavy';
            else if(rnd > 0.65) type = 'shooter';
            else if(rnd > 0.35) type = 'scout';

            const st = {
                scout: { spd: 60, hp: 20, col: CONFIG.COLORS.SCOUT, scl: 0.8, dmg: 2, range: 1.5, rate: 0.8 }, 
                rusher: { spd: 42, hp: 45, col: CONFIG.COLORS.RUSHER, scl: 1.2, dmg: 4, range: 2, rate: 0.8 },
                heavy: { spd: 24, hp: 120, col: CONFIG.COLORS.HEAVY, scl: 1.8, dmg: 10, range: 2.5, rate: 0.8 },
                shooter: { spd: 33, hp: 35, col: CONFIG.COLORS.SHOOTER, scl: 1.0, dmg: 5, range: 20, rate: 0.3 }, 
                tyrant: { spd: 66, hp: 200, col: CONFIG.COLORS.TYRANT, scl: 2.5, dmg: 8, range: 2, rate: 0.8 },
                elite: { spd: 50, hp: 80, col: CONFIG.COLORS.ELITE, scl: 1.3, dmg: 1, range: 20, rate: 0.15 },
                pyro: { spd: 25, hp: 60, col: CONFIG.COLORS.PYRO, scl: 1.1, dmg: 0, range: 25, rate: 3.0 },
                leech: { spd: 80, hp: 10, col: CONFIG.COLORS.LEECH, scl: 0.5, dmg: 0, range: 15, rate: 0.5 } 
            }[type];

            const body = new CANNON.Body({ mass: 5, position: new CANNON.Vec3(x, 2, z), fixedRotation: true });
            body.addShape(new CANNON.Cylinder(0.8*st.scl, 0.8*st.scl, 2*st.scl, 8));
            world.addBody(body);

            const grp = new THREE.Group();
            let geo;
            if(type==='scout') geo = new THREE.ConeGeometry(0.8, 2, 4);
            else if(type==='rusher') geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            else if(type==='heavy') geo = new THREE.CylinderGeometry(1, 1, 2.5, 16);
            else if(type==='tyrant') geo = new THREE.DodecahedronGeometry(1);
            else if(type==='elite') geo = new THREE.IcosahedronGeometry(1);
            else if(type==='pyro') geo = new THREE.OctahedronGeometry(1); 
            else if(type==='leech') geo = new THREE.TetrahedronGeometry(1); 
            else geo = new THREE.OctahedronGeometry(1);

            const mat = new THREE.MeshStandardMaterial({ 
                map: gradients[type],
                emissive: st.col,
                emissiveMap: gradients[type],
                emissiveIntensity: 1.0,
                roughness: 0.2
            });
            const m = new THREE.Mesh(geo, mat);
            m.scale.setScalar(st.scl);
            
            if(type === 'tyrant' || type === 'heavy' || type === 'elite' || type === 'pyro' || type === 'leech') {
                const l = new THREE.PointLight(st.col, 1, 8);
                m.add(l);
            }

            // HEALTH BAR
            const barGeo = new THREE.PlaneGeometry(1.5 * st.scl, 0.2);
            const barMat = new THREE.MeshBasicMaterial({ map: hpBarTexture });
            const bar = new THREE.Mesh(barGeo, barMat);
            bar.position.y = 2 * st.scl;
            
            const bgGeo = new THREE.PlaneGeometry(1.6 * st.scl, 0.3);
            const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const bg = new THREE.Mesh(bgGeo, bgMat);
            bg.position.y = 2 * st.scl;
            bg.position.z = -0.01;

            grp.add(bg);
            grp.add(bar);
            grp.add(m); 
            grp.position.set(x, 0, z); scene.add(grp);
            enemies.push({ mesh:grp, body, hp:st.hp, max:st.hp, type, st, lastAtk:0, hpBar: bar });
        }

        function killEnemy(e) {
            scene.remove(e.mesh); world.removeBody(e.body);
            // REMOVED EXPLOSION PARTICLES
            // spawnExplosion(e.mesh.position, e.st.col, 6); 
            spawnLoot(e.mesh.position);
            const idx = enemies.indexOf(e);
            if(idx > -1) enemies.splice(idx, 1);
        }

        function updateEntities() {
            for(let i=fireZones.length-1; i>=0; i--) {
                const z = fireZones[i];
                z.life -= delta;
                if(z.life <= 0) { scene.remove(z.mesh); fireZones.splice(i,1); continue; }
                
                if(z.isPlayerOwned) {
                    enemies.forEach(e => {
                        if(e.mesh.position.distanceTo(z.pos) < 7) {
                            e.hp -= 30 * delta;
                            if(e.hp<=0) killEnemy(e);
                        }
                    });
                } else {
                    if(playerMesh.position.distanceTo(z.pos) < 7) {
                        hitPlayer(3 * delta); 
                    }
                }
                
                z.mesh.material.opacity = 0.4 + Math.random()*0.4;
            }

            for(let i=bullets.length-1; i>=0; i--) {
                const b = bullets[i];
                b.life -= delta;
                b.mesh.position.add(b.vel.clone().multiplyScalar(delta));
                
                let hitProp = false;
                for(let p of dynamicProps) {
                    // Optimized Collision Check using Box3
                    if(p.box.containsPoint(b.mesh.position)) {
                       hitProp = true; break;
                    }
                }
                
                if(!b.piercing && hitProp) {
                    scene.remove(b.mesh); bullets.splice(i,1); continue;
                }

                let hit = false;
                for(let e of enemies) {
                    if(b.mesh.position.distanceTo(e.mesh.position) < 2.5 * e.st.scl) {
                        if(b.piercing) {
                            if(!b.hitIds.includes(e.body.id)) {
                                e.hp -= b.dmg;
                                b.hitIds.push(e.body.id);
                                e.mesh.children[2].material.emissiveIntensity = 5.0; 
                                setTimeout(() => { if(e.mesh) e.mesh.children[2].material.emissiveIntensity = 1.0; }, 50);
                                if(e.hp <= 0) killEnemy(e);
                            }
                        } else {
                            e.hp -= b.dmg;
                            hit = true;
                            e.mesh.children[2].material.emissiveIntensity = 5.0;
                            setTimeout(() => { if(e.mesh) e.mesh.children[2].material.emissiveIntensity = 1.0; }, 50);
                            if(e.hp <= 0) killEnemy(e);
                            break;
                        }
                    }
                }
                if((hit && !b.piercing) || b.life <= 0) { scene.remove(b.mesh); bullets.splice(i,1); }
            }

            for(let i=enemyBullets.length-1; i>=0; i--) {
                const b = enemyBullets[i];
                b.life -= delta; b.mesh.position.add(b.vel.clone().multiplyScalar(delta));
                if(b.mesh.position.distanceTo(playerMesh.position) < 2.5) {
                    hitPlayer(b.dmg); scene.remove(b.mesh); enemyBullets.splice(i,1); continue;
                }
                if(b.life <= 0) { scene.remove(b.mesh); enemyBullets.splice(i,1); }
            }

            for(let i=enemyProjectiles.length-1; i>=0; i--) {
                const p = enemyProjectiles[i];
                p.progress += delta * 1.0; 
                
                const currentPos = new THREE.Vector3().lerpVectors(p.start, p.target, p.progress);
                currentPos.y += Math.sin(p.progress * Math.PI) * 10; 
                p.mesh.position.copy(currentPos);
                p.mesh.rotation.x += delta * 5;
                p.mesh.rotation.z += delta * 5;

                // REMOVED SPARKS GENERATION

                if(p.progress >= 1) {
                    scene.remove(p.mesh);
                    enemyProjectiles.splice(i,1);
                    // REMOVED EXPLOSION PARTICLES
                    // spawnExplosion(p.target, 0xff4400, 6);
                    
                    const zone = new THREE.Mesh(new THREE.CircleGeometry(8, 32), new THREE.MeshBasicMaterial({color:0xff0044, side:THREE.DoubleSide, transparent:true, opacity:0.6}));
                    zone.rotation.x = -Math.PI/2; zone.position.copy(p.target); zone.position.y = 0.1;
                    scene.add(zone);
                    fireZones.push({ mesh:zone, pos:p.target, life:5.0, isPlayerOwned: false });
                }
            }

            const pPos = playerMesh.position;
            enemies.forEach(e => {
                e.hpBar.scale.x = Math.max(0, e.hp / e.max);
                e.hpBar.lookAt(camera.position); 

                const dist = pPos.distanceTo(e.mesh.position);
                const dir = new CANNON.Vec3().copy(playerBody.position).vsub(e.body.position);
                dir.y = 0; dir.normalize();

                let move = true;
                
                if(e.type === 'leech') {
                    if(dist < 15 && !PLAYER.leechAttached) {
                        e.body.velocity.set(dir.x*80, 5, dir.z*80);
                        move = false;
                        if(dist < 2.0) {
                            attachLeech();
                            killEnemy(e); 
                            return;
                        }
                    }
                } else if(dist < e.st.range) {
                    move = false;
                    if(e.type !== 'shooter' && e.type !== 'elite' && e.type !== 'pyro' && STATE.time > e.lastAtk + 0.8) {
                        e.lastAtk = STATE.time;
                        hitPlayer(e.st.dmg);
                    }
                }

                if(e.type === 'shooter') {
                    if(dist < e.st.range) {
                        move = false; e.body.velocity.set(0,0,0);
                        if(STATE.time > e.lastAtk + e.st.rate) { 
                            e.lastAtk = STATE.time;
                            const sDir = new THREE.Vector3().subVectors(pPos, e.mesh.position).normalize();
                            spawnBullet(e.mesh.position.clone().add(new THREE.Vector3(0,2,0)), sDir, e.st.dmg, false);
                        }
                    }
                }

                if(e.type === 'elite') {
                    if(dist < e.st.range) {
                        move = false; e.body.velocity.set(0,0,0);
                        if(STATE.time > e.lastAtk + e.st.rate) {
                            e.lastAtk = STATE.time;
                            const sDir = new THREE.Vector3().subVectors(pPos, e.mesh.position).normalize();
                            const origin = e.mesh.position.clone().add(new THREE.Vector3(0,2,0));
                            for(let i=0; i<3; i++) {
                                const spread = (Math.random()-0.5) * 0.3;
                                const finalDir = sDir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), spread);
                                spawnBullet(origin, finalDir, e.st.dmg, false);
                            }
                        }
                    }
                }

                if(e.type === 'pyro') {
                    if(dist < e.st.range) {
                        move = false; e.body.velocity.set(0,0,0);
                        if(STATE.time > e.lastAtk + e.st.rate) {
                            e.lastAtk = STATE.time;
                            const mGeo = new THREE.DodecahedronGeometry(0.5);
                            const mMat = new THREE.MeshBasicMaterial({color: 0xff4444});
                            const mMesh = new THREE.Mesh(mGeo, mMat);
                            mMesh.position.copy(e.mesh.position).add(new THREE.Vector3(0,2,0));
                            scene.add(mMesh);
                            enemyProjectiles.push({
                                mesh: mMesh,
                                start: mMesh.position.clone(),
                                target: pPos.clone(),
                                progress: 0
                            });
                        }
                    }
                }

                if(move) {
                    e.body.velocity.x = dir.x * e.st.spd;
                    e.body.velocity.z = dir.z * e.st.spd;
                }
                e.mesh.lookAt(pPos);
                e.mesh.position.copy(e.body.position);
                e.mesh.position.y -= 1; 
                e.mesh.quaternion.copy(e.body.quaternion);
            });
        }

        function updateParticles() {
            // PULSING GRID
            if(STATE.grid) {
                const scale = 1 + Math.sin(STATE.time * 2) * 0.02;
                STATE.grid.scale.set(scale, 1, scale);
            }

            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.life -= delta;
                if (p.vel instanceof THREE.Vector3) {
                    p.mesh.position.add(p.vel.clone().multiplyScalar(delta));
                }
                
                if(p.type === 'scar') {
                    p.life -= delta; 
                    if(p.life <= 0) {
                        scene.remove(p.mesh);
                        particles.splice(i,1);
                    }
                    continue;
                }

                if (p.type === 'meteor' || p.type === 'snow') {
                    if(p.indicator) {
                        p.indicator.scale.multiplyScalar(1.02);
                        p.indicator.material.opacity = 0.5 + Math.sin(STATE.time*20)*0.5;
                    }

                    if (p.mesh.position.y <= 0) {
                        
                        // PLAY SOUND
                        playImpactSound(p.type);

                        if(p.type === 'snow') {
                            // REMOVED EXPLOSION PARTICLES
                            showNotification("FROST IMPACT");
                            if(playerMesh.position.distanceTo(p.mesh.position) < 10) {
                                hitPlayer(4); 
                                PLAYER.frozenTimer = 0.5;
                            }
                        } else {
                            // REMOVED EXPLOSION PARTICLES
                            if(playerMesh.position.distanceTo(p.mesh.position) < 12) hitPlayer(30);
                        }
                        
                        scene.remove(p.mesh); 
                        
                        const scar = p.indicator; 
                        scar.material.color.setHex(0x222222);
                        scar.material.opacity = 0.5;
                        particles.push({mesh:scar, type:'scar', life: 10.0}); 
                        
                        particles.splice(i,1);
                        continue;
                    }
                } else {
                    p.vel.y -= 25 * delta;
                    p.mesh.rotation.x += delta * 5;
                }

                if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i,1); }
            }
        }

        function spawnExplosion(pos, col, count) {
            // DELETED AS REQUESTED
        }

        function updateMeteors() {
            if(!STATE.hellRain && STATE.time > STATE.lastMeteor + 5) {
                STATE.hellRain = true; STATE.lastMeteor = STATE.time;
                showNotification("METEOR DETECTED");
                
                let count = 0;
                let maxMeteors = 10 + (STATE.level * 2); 

                const barrage = setInterval(() => {
                    const type = (STATE.level >= 2 && Math.random() > 0.5) ? 'snow' : 'fire';
                    spawnMeteor(type);
                    count++;
                    if(count > maxMeteors) { 
                        clearInterval(barrage); 
                        STATE.hellRain = false; 
                    }
                }, 100); 
            }
        }

        function spawnMeteor(type) {
            const range = CONFIG.ARENA_SIZE + 15; 
            const x = Math.max(-range, Math.min(range, (Math.random()-.5)*180 + playerMesh.position.x*0.2));
            const z = Math.max(-range, Math.min(range, (Math.random()-.5)*180 + playerMesh.position.z*0.2));
            
            const col = 0x555555; 
            const ind = new THREE.Mesh(new THREE.RingGeometry(0.5, 1, 16), new THREE.MeshBasicMaterial({color:col, side:THREE.DoubleSide, transparent:true}));
            ind.rotation.x = -Math.PI/2; ind.position.set(x, 0.2, z);
            scene.add(ind);

            const mCol = type === 'snow' ? 0xccffff : 0xff4400;
            const m = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshBasicMaterial({ color: mCol, wireframe: true }));
            m.position.set(x, 80, z);
            scene.add(m);

            particles.push({ 
                mesh: m, indicator: ind,
                vel: new THREE.Vector3(0, -60, 0), life: 5.0, type: type
            });
        }

        function spawnLoot(pos) {
            if(Math.random()>0.7) return; 
            const type = Math.random()>0.7 ? 'hp' : 'ammo';
            const col = type==='hp' ? 0x00ff00 : 0x0088ff;
            const geo = type==='hp' ? new THREE.BoxGeometry(0.8, 0.8, 0.8) : new THREE.OctahedronGeometry(0.5);
            const m = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:col, wireframe:true}));
            m.position.copy(pos); m.position.y = 1; scene.add(m);
            loot.push({mesh:m, type, life: type==='hp' ? 25 : 30});
        }

        function checkLoot() {
            for(let i=loot.length-1; i>=0; i--) {
                const l = loot[i];
                l.mesh.rotation.y += delta * 3;
                l.life -= delta;
                
                if(l.life < 3) l.mesh.visible = Math.floor(STATE.time * 10) % 2 === 0;

                if(l.life <= 0) {
                    scene.remove(l.mesh); loot.splice(i,1); continue;
                }

                if(playerMesh.position.distanceTo(l.mesh.position) < 3.5) {
                    let taken = false;
                    if(l.type==='hp') {
                        if(PLAYER.hp < PLAYER.maxHp) { PLAYER.hp = Math.min(PLAYER.hp+25, 100); taken = true; }
                    } else {
                            WEAPONS.forEach(wp => wp.ammo = Math.min(wp.ammo + Math.floor(wp.max*0.5), wp.max));
                            taken = true;
                    }
                    if(taken) {
                        scene.remove(l.mesh); loot.splice(i,1);
                        updateHUD();
                        const msg = document.getElementById('loot-msg');
                        if (msg) { msg.classList.remove('hidden'); setTimeout(()=>msg.classList.add('hidden'), 1000); }
                    }
                }
            }
        }

        function handleReload() {
            if(PLAYER.reloading) return;
            PLAYER.reloading = true;
            
            const barBg = document.getElementById('reload-bar-bg');
            const barFill = document.getElementById('reload-bar-fill');
            barBg.style.display = 'block';
            barFill.style.transition = 'none';
            barFill.style.width = '0%';
            
            const ammoTxt = document.getElementById('ammo-cur');
            ammoTxt.classList.add('reloading-text');
            
            void barFill.offsetWidth;

            barFill.style.transition = 'width 0.8s linear';
            barFill.style.width = '100%';

            setTimeout(() => {
                WEAPONS[PLAYER.wepIdx].ammo = WEAPONS[PLAYER.wepIdx].max;
                PLAYER.reloading = false;
                barBg.style.display = 'none';
                ammoTxt.classList.remove('reloading-text');
                updateHUD();
            }, 800);
        }

        function hitPlayer(dmg) {
            PLAYER.hp -= dmg;
            updateHUD();
            if(PLAYER.hp <= 0) gameOver();
        }

        function updateHUD() {
            const w = WEAPONS[PLAYER.wepIdx];
            document.getElementById('weapon-name').innerText = w.name;
            document.getElementById('ammo-cur').innerText = w.ammo;
            document.getElementById('bar-hp').style.width = PLAYER.hp+'%';
            document.getElementById('bar-sp').style.width = PLAYER.sp+'%';
            document.getElementById('molotov-count').innerText = 'x' + PLAYER.molotovCharges;
        }

        function swap(i) { if(!PLAYER.reloading) { PLAYER.wepIdx = i; updateHUD(); } }

        function startGame() {
            initAudio(); // Init audio context on user gesture
            const bgm = document.getElementById('bgm');
            bgm.play().catch(e => console.log("Audio play blocked:", e));

            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('hud').classList.remove('hidden');
            STATE.isRunning = true;
            STATE.level = 1;
            STATE.nextLevelTime = 30;
            spawnRate = 300;
            maxEnemies = 200;
            
            PLAYER.sp = 100;
            
            gsap.to(camera.position, {x:0, y:50, z:30, duration: 1.5});
            
            for(let i=0; i<15; i++) spawnEnemy();
            
            if(spawnInterval) clearInterval(spawnInterval);
            spawnInterval = setInterval(spawnEnemy, spawnRate);
        }
        
        function resetGame() {
            STATE.isRunning = false;
            if(spawnInterval) clearInterval(spawnInterval);

            enemies.forEach(e => { scene.remove(e.mesh); world.removeBody(e.body); });
            enemies = [];
            
            bullets.forEach(b => { scene.remove(b.mesh); });
            bullets = [];
            
            enemyBullets.forEach(b => { scene.remove(b.mesh); });
            enemyBullets = [];

            enemyProjectiles.forEach(p => { scene.remove(p.mesh); });
            enemyProjectiles = [];
            
            particles.forEach(p => { scene.remove(p.mesh); if(p.indicator) scene.remove(p.indicator); });
            particles = [];
            
            fireZones.forEach(z => scene.remove(z.mesh));
            fireZones = [];
            
            loot.forEach(l => scene.remove(l.mesh));
            loot = [];

            regenerateMap();

            world.removeBody(playerBody);
            scene.remove(playerMesh);
            createPlayer();
            
            PLAYER.hp = 100; PLAYER.sp = 100; PLAYER.molotovCharges = 2; PLAYER.wepIdx = 0; PLAYER.frozenTimer = 0;
            PLAYER.reloading = false;
            PLAYER.dashCd = false;
            PLAYER.leechAttached = false;
            PLAYER.leechSlowTimer = 0;
            document.getElementById('leech-warning').style.display = 'none';
            document.getElementById('slowed-label').style.display = 'none';
            attachedLeechMesh = null;

            WEAPONS.forEach(w => {
                w.ammo = w.max;
                w.lastShot = 0;
            });
            
            STATE.time = 0;
            document.getElementById('timer').innerText = "00:00";
            document.getElementById('level-display').innerText = "THREAT LEVEL: 1";
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('frost-overlay').classList.add('hidden');
            document.getElementById('reload-bar-bg').style.display = 'none';
            document.getElementById('ammo-cur').classList.remove('reloading-text');
            
            updateHUD();
            startGame();
        }

        function gameOver() {
            STATE.isRunning = false;
            document.getElementById('game-over').classList.remove('hidden');
            document.getElementById('game-over').classList.add('flex');
            document.getElementById('reload-bar-bg').style.display = 'none';
            document.getElementById('ammo-cur').classList.remove('reloading-text');
            
            const m = Math.floor(STATE.time/60).toString().padStart(2,'0');
            const s = Math.floor(STATE.time%60).toString().padStart(2,'0');
            
            let count = 0;
            const final = Math.floor(STATE.time);
            const el = document.getElementById('final-time');
            const counter = setInterval(() => {
                count += 1;
                const mm = Math.floor(count/60).toString().padStart(2,'0');
                const ss = Math.floor(count%60).toString().padStart(2,'0');
                el.innerText = `${mm}:${ss}`;
                if(count >= final) clearInterval(counter);
            }, 20);
            
            if(spawnInterval) clearInterval(spawnInterval);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if(!STATE.isRunning) {
                orbitAngle += 0.005;
                camera.position.x = Math.sin(orbitAngle) * 40;
                camera.position.z = Math.cos(orbitAngle) * 40;
                camera.lookAt(0,0,0);
                composer.render();
                return;
            }

            delta = Math.min(clock.getDelta(), 0.1);
            STATE.time += delta;
            world.step(1/60, delta, 3);
            updatePlayer();
            handleShooting();
            updateEntities();
            updateParticles();
            checkLoot();
            updateMeteors();
            const m = Math.floor(STATE.time/60).toString().padStart(2,'0');
            const s = Math.floor(STATE.time%60).toString().padStart(2,'0');
            document.getElementById('timer').innerText = `${m}:${s}`;
            
            if(STATE.mapGlitching) {
                STATE.glitchTimer -= delta;
                dynamicProps.forEach(p => {
                    if(Math.random() > 0.5) {
                        p.mesh.scale.multiplyScalar(1.0 + (Math.random()-0.5)*0.2); 
                    } else {
                        p.mesh.scale.copy(p.originalScale);
                    }
                });
                if(STATE.glitchTimer <= 0) {
                    STATE.mapGlitching = false;
                    dynamicProps.forEach(p => p.mesh.scale.copy(p.originalScale));
                }
            }

            if(STATE.time > STATE.nextLevelTime && STATE.level < 10) {
                STATE.level++;
                STATE.nextLevelTime += 30;

                regenerateMap();

                if(STATE.level === 3) {
                    spawnRate = 300; 
                    maxEnemies = 200;
                    showNotification("DOUBLE THREAT");
                } else if (STATE.level > 3) {
                    spawnRate = Math.max(100, spawnRate - 50); 
                    maxEnemies += 50;
                    showNotification("CHAOS RISING");
                }
                
                clearInterval(spawnInterval);
                spawnInterval = setInterval(spawnEnemy, spawnRate);
                
                document.getElementById('level-display').innerText = "THREAT LEVEL: " + STATE.level;
            }
            composer.render();
        }

        init();
    </script>
</body>
</html>